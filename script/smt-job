#!/usr/bin/perl

###############################################################################
## Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use SMT::CLI;
use SMT::Utils;
use SMT::Client;
use SMT::JobQueue;
use SMT::Job;

use Text::ASCIITable;
use File::Basename;
use Locale::gettext ();
#use UNIVERSAL 'isa';
use POSIX ();     # Needed for setlocale()

use Data::Dumper;

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

use constant JOB_TYPE    =>
  {
    # Maps JOB_TYPE ID to JOB_TYPE NAME
    1       => 'patchstatus',
    2       => 'softwarepush',
    3       => 'update',
    4       => 'execute',
    5       => 'reboot',
    6       => 'configure',
    7       => 'wait',
    8       => 'eject',

    # Maps JOB_TYPE NAME to JOB_TYPE ID
    'patchstatus'   =>      1,
    'softwarepush'  =>      2,
    'update'        =>      3,
    'execute'       =>      4,
    'reboot'        =>      5,
    'configure'     =>      6,
    'wait'          =>      7,
    'eject'         =>      8,
  };

#### START LOCAL FUNCTIONS ####

sub getJobTypeID($)
{
    my $q = shift || return undef;

    if ( $q =~ /^\d+$/ )
    {
        return $q if exists JOB_TYPE->{$q};
        return undef;
    }
    elsif ( exists JOB_TYPE->{$q}  )
    {
        return  JOB_TYPE->{$q};
    }

    return undef;
}



#### END LOCAL FUNCTIONS ####


if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

# connect to database
my ($cfg, $dbh) = SMT::CLI::init();
if (! defined $dbh) {
    print __("Cannot connect to database");
    exit 3;
}


my ($verbose, $help, $quiet) = undef;
my ($create, $edit, $delete, $list, @guid, $jobid, $deleteall, $type, $name, $description, $targeted, $expires, $timelag, $finished, $verbosejob, $persistent, $parent, @SWpackagelist, $SWforce, $SWagree, $EXECcommand, $WAITtime, $WAITstatus) = undef;

use Getopt::Long;
&Getopt::Long::Configure( 'pass_through', 'no_autoabbrev', 'no_ignore_case');
&Getopt::Long::GetOptions(
         'help|h' => \$help,
         'verbose|v' => \$verbose,
         'quiet|q' => \$quiet,
         # the four basic modes of smt job
         'create|c' => \$create,
         'edit|e' => \$edit,
         'delete|d' => \$delete,
         'list|l' => \$list,
         # job identifier
         'guid|g=s' => \@guid,
         'jobid|j=i' => \$jobid,
         'deleteall|A' => \$deleteall,
         # data fields for create and edit:
         'type|t=s' => \$type,
         'name|n=s' => \$name,
         'description=s' => \$description,
         'targeted=s' => \$targeted,
         'expires=s' =>  \$expires,
         'timelag=s' =>  \$timelag,
         # general switches
         'finished|f!' => \$finished,
         'verbosejob|V!' => \$verbosejob,
         'persistent!' => \$persistent,
         'parent=i' => \$parent,
         # job specific arguments
         'package|P=s@' => \@SWpackagelist,
         'forceinstall|F!' => \$SWforce,
         'agreelicense|L!' => \$SWagree,
         'exec|X=s' => \$EXECcommand,
         'waittime=i' => \$WAITtime,
         'waitstatus=i' => \$WAITstatus
);

if ( defined $help and ( $help == 1 ) )
{
  print basename($0) . " : " . __("list jobs from SMT job queue")."\n";
  print "   --help        (-h) : " . __("show this help")."\n";
  print "   --verbose     (-v) : " . __("show detailed job information")."\n";
  print "   --quiet       (-q) : " . __("quiet mode, suppress success messages")."\n";
  print "\n";
  print ' '.__("basic operation modes")."\n";
  print "   --list        (-l) : " . __("list jobs (default)")."\n";
  print "   --create      (-c) : " . __("create job")."\n";
  print "   --edit        (-e) : " . __("edit job")."\n";
  print "   --delete      (-d) : " . __("delete job")."\n";
  print "\n";
  print ' '.__("main parameters")."\n";
  print "   --guid        (-g) <guid> : " . __("the clients guid")."\n";
  print __("                               can be used multiple times when creating a job")."\n";
  print "   --jobid       (-j) <id>   : " . __("the jobid")."\n";
  print __("                        will be ignored when creating a job")."\n";
  print "   --deleteall   (-A)        : " . __("allows to omit either the guid or the jobid parameter")."\n";
  print __("                       the missing parameter will then match all")."\n";
  print "\n";
  print ' '.__("parameters to search for or change")."\n";
  print "   --type        (-t) <type> : " . __("job type (name or its id)")."\n";
  print "   --name        (-n) <name> : " . __("job name")."\n";
  print "   --description      <desc> : " . __("job description")."\n";
  print "   --parent           <id>   : " . __("parent job, describes a dependency")."\n";
  print "   --verbosejob  (-V)        : " . __("verbosity of job")."\n";
  print "   --persistent              : " . __("persistency of job")."\n";
  print "   --finished                : " . __("finds finished jobs")."\n";
  print "\n";
  print ' '.__("parameters for timing (timeformat: see below)")."\n";
  print "   --targeted                : " . __("targeted date and time")."\n";
  print "   --expires                 : " . __("date and time when job expires")."\n";
  print "   --timelag                 : " . __("time interval for persistent jobs")."\n";
  print "\n";
  print ' '.__("job specific parameters (only for creating a job)")."\n";
  print '  '.__("for software push jobs")."\n";
  print "   --package     (-P) <pack> : " . __("a package name")."\n";
  print __("                               can be used multiple times")."\n";
  print "   --forceinstall (-F)       : " . __("enforce the installation")."\n";
  print "   --agreelicense (-L)       : " . __("auto-agree to licenses")."\n";
  print '  '.__("for execute jobs")."\n";
  print "   --exec         (-X) <cmd> : " . __("the command to execute")."\n";
  print '  '.__("for wait jobs")."\n";
  print "   --waittime         <time> : " . __("time in seconds the job should take")."\n";
  print "   --waitstatus       <exit> : " . __("exit code for the job to return with")."\n";
  print "\n";
  print ' '.__("used time format")."\n";
  print "   targeted/expires          : " . __("'YYYY-MM-DD[-HH:MM[:SS]]'")."\n";
  print "   timelag                   : " . __("'HH:MM[:SS]'")."\n";


  exit 0;
}

########################################################################################
#
# get and check all passed parameters
#

my %query = ();

my $GUID = undef;
if (@guid && @guid > 0)
{
    # searching only supports one guid
    $query{'GUID'} = $guid[0];
    # for methods that only operate on one guid
    $GUID = $guid[0];
}
else
{
    @guid = undef;
}
$query{'ID'} = $jobid if (defined $jobid);

my $typeID = getJobTypeID($type);
if ( defined $type && not defined $typeID )
{
    print "Job type unkown.\n";
    exit 4;
}
$query{'TYPE'} = $typeID if (defined $typeID);
$query{'NAME'} = $name if (defined $name);
$query{'DESCRIPTION'} = $description if (defined $description);
# check time format
$query{'TARGETED'} = $targeted if (defined $targeted);
$query{'EXPIRES'} = $expires if (defined $expires);
$query{'TIMELAG'} = $timelag if (defined $timelag);

if ( exists $query{'TARGETED'} )
{
    if ( $query{'TARGETED'} !~ /^\d{4}-\d{2}-\d{2}[-_+ ](\d{2}:\d{2}(:\d{2})?)?$/ )
    {
	print __("Invalid time format for 'targeted' time.")."\n";
	exit 4;
    }
}
if ( exists $query{'EXPIRES'} )
{
    if ( $query{'EXPIRES'} !~ /^\d{4}-\d{2}-\d{2}[-_+ ](\d{2}:\d{2}(:\d{2})?)?$/ )
    {
	print __("Invalid time format for 'expires' time.")."\n";
	exit 4;
    }
}
if ( exists $query{'TIMELAG'} )
{
    if ( $query{'TIMELAG'} !~ /^\d{2}:\d{2}(:\d{2})?$/ )
    {
	print __("Invalid time format for 'timelag'.")."\n";
	exit 4;
    }
}


if (defined $finished)
{
    $query{'FINISHED+'} = 'NULL' if ($finished);
    $query{'FINISHED-'} = 'NULL' if (not $finished);
}

$query{'VERBOSE'} = $verbosejob if (defined $verbosejob);
$query{'PERSISTENT'} = $persistent if (defined $persistent);
$query{'PARENT'} = $persistent if (defined $parent);

my %para = ();
$para{'PACKAGELIST'} = \@SWpackagelist if (@SWpackagelist);
$para{'SWFORCE'} = $SWforce if (defined $SWforce);
$para{'EXECCOMMAND'} = $EXECcommand if (defined $EXECcommand);
$para{'WAITTIME'} = $WAITtime if (defined $WAITtime);
$para{'WAITSTATUS'} = $WAITstatus if (defined $WAITstatus);



#######################################################################################
#
# MAIN routine
#


my $JobQ = SMT::JobQueue->new({ 'dbh' => $dbh });
my $Job = SMT::Job->new({ 'dbh' => $dbh });
## my $Client = SMT::Client->new({'dbh' => $dbh});

my $opc = 0;
$opc++ if (defined $create);
$opc++ if (defined $edit);
$opc++ if (defined $delete);
$opc++ if (defined $list);
if ( $opc > 1 )
{
    print __("Please define only one operation mode.")."\n";
    exit 3;
}


if ( defined $create )
{
    ## CREATE ##

    if ( not defined $typeID )
    {
        print __("The job type is invalid.")."\n";
        exit 3;
    }
    if ( not defined $GUID )
    {
        print __("The guid is invalid.")."\n";
        exit 3;
    }

    $Job->newJob( @guid > 0 ? undef:$GUID, undef, $typeID, undef );

    # fill in parameters if they are specified - maybe overwritten in job type handling below
    $Job->{'name'}        = $query{'NAME'}        if ( exists $query{'NAME'}        && defined $query{'NAME'} );
    $Job->{'description'} = $query{'DESCRIPTION'} if ( exists $query{'DESCRIPTION'} && defined $query{'DESCRIPTION'} );
    $Job->{'verbose'}     = $query{'VERBOSE'}     if ( exists $query{'VERBOSE'}     && defined $query{'VERBOSE'} );
    $Job->{'persistent'}  = $query{'PERSISTENT'}  if ( exists $query{'PERSISTENT'}  && defined $query{'PERSISTENT'} );
    $Job->{'parent'}      = $query{'PARENT'}      if ( exists $query{'PARENT'}      && defined $query{'PARENT'} );
    $Job->{'targeted'}    = $query{'TARGETED'}    if ( exists $query{'TARGETED'}    && defined $query{'TARGETED'} );
    $Job->{'expires'}     = $query{'EXPIRES'}     if ( exists $query{'EXPIRES'}     && defined $query{'EXPIRES'} );
    $Job->{'timelag'}     = $query{'TIMELAG'}     if ( exists $query{'TIMELAG'}     && defined $query{'TIMELAG'} );

    if ( $typeID == 1 )
    {
        ## PATCHSTATUS ##
        $Job->{'name'}        = $query{'NAME'} || 'Patchstatus Job';
        $Job->{'description'} = $query{'DESCRIPTION'} || "Patchstatus Job for Client $GUID";
        $Job->{'persistent'}  = $query{'PERSISTENT'} || 1;
        $Job->{'timelag'}     = $query{'TIMELAG'} || '23:00';
    }
    elsif ( $typeID == 2 )
    {
        ## SOFTWARE PUSH ##

        if ( not @SWpackagelist || @SWpackagelist == 0 )
        {
            print __("Please define at least one package for a software push job.");
            exit 3;
        }

        $Job->{'name'}        = $query{'NAME'} || 'Software Push';        
        $Job->{'description'} = $query{'DESCRIPTION'} || sprintf("Software Push: %s", join(', ', @SWpackagelist) );
        $Job->{'arguments'}   = { 'packages' => [ { 'package' => \@SWpackagelist } ] };
        $Job->{'arguments'}{'force'} = $SWforce if (defined $SWforce);
        $Job->{'arguments'}{'agreelicenses'} = $SWagree if (defined $SWagree);
    }
    elsif ( $typeID == 3 )
    {
        ## update ##
        $Job->{'name'}        = $query{'NAME'} || 'Software Push';
        $Job->{'description'} = $query{'DESCRIPTION'} || sprintf("Software Push: %s", join(', ', @SWpackagelist) );
        $Job->{'arguments'}   = { 'packages' => [ { 'package' => \@SWpackagelist } ]  };
    }
    elsif ( $typeID == 4 )
    {
        ## exec ##
        $Job->{'name'}        = $query{'NAME'} || 'Execute';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Execute custom command';
        $Job->{'arguments'}{'command'} = (exists $para{'EXECCOMMAND'} && defined $para{'EXECCOMMAND'}) ? $para{'EXECCOMMAND'} : ' /bin/true ' ;
    }
    elsif ( $typeID == 5 )
    {
        ## reboot ##
        $Job->{'name'}        = $query{'NAME'} || 'Reboot';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Reboot now';
    }
    elsif ( $typeID == 6 )
    {
        ## configure ##
        print __("The configure job type is not supported. Its reserved for future use.")."\n";
        exit 1;
    }
    elsif ( $typeID == 7 )
    {
        ## wait ##
        my $sec = $para{'WAITTIME'} || '1';
        my $ret = $para{'WAITSTATUS'} || '0';

        $Job->{'name'}        = $query{'NAME'} || sprintf("Wait %s sec. for exit %s.", $sec, $ret );
        $Job->{'description'} = $query{'DESCRIPTION'} || sprintf("Wait for %s seconds and return with value %s.", $sec, $ret );
        $Job->{'arguments'}{'waittime'} = $sec;
        $Job->{'arguments'}{'exitcode'} = $ret;
    }
    elsif ( $typeID == 8 )
    {
        ## eject ##
        $Job->{'name'}        = $query{'NAME'} || 'Eject job';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Job to eject the CD/DVD drawer';
    }
    else
    {
        print __("This job type is unsupported.")."\n";
        exit 3;
    }

    my $newjobid = undef;
    if (@guid > 0)
    {
        ##  job for multiple guids ##
        $newjobid = $JobQ->addJobForMultipleGUIDs($Job, @guid);
    }
    else
    {
        ## single job ##
        $newjobid = $Job->save();
    }

    if ( $newjobid )
    {
        print sprintf(__("Successfully created new job. The job id is: %s"), $newjobid )."\n" unless $quiet;
    }
    else
    {
        print __("An error occurred when creating a new job.")."\n";
    }


}
elsif ( defined $edit )
{
    ## EDIT  ##

    if ( (not defined $GUID) || ( not defined $jobid ) )
    {
        print __("Please define one job id and one guid to edit a job.")."\n";
        exit 3;
    }

    # get job data from database
    $Job->readJobFromDatabase($jobid, $GUID);

    # overwrite with new values
    my @EditProps = qw(NAME DESCRIPTION VERBOSE PERSISTENT PARENT TARGETED EXPIRES TIMELAG);
    foreach my $eprop (@EditProps)
    {
        $Job->{lc($eprop)} = $query{uc($eprop)} if ( exists $query{uc($eprop)}  && defined $query{uc($eprop)} );
    }

    # save job
    my $result = $Job->save();
    if ($result)
    {
        print __("Successfully saved the edited job.")."\n" unless $quiet;
    }
    else
    {
        print __("An error occurred when saving the edited job.")."\n";
    }
}
elsif ( defined $delete )
{
    ##  DELETE  ##

    if ( not defined $jobid )
    {
        print __("The job id is invalid.")."\n";
        exit 3;
    }
    if ( not defined $GUID )
    {
        if ( not $deleteall )
        {
            print __("The guid is invalid.")."\n";
            exit 3;
        }
    }

    if ($deleteall)
    {
        print sprintf(__("Deleting job %s for all guids."), $jobid, $GUID )."\n" unless $quiet;
    }
    else
    {
        print sprintf(__("Deleting job %s for guid %s."), $jobid, $GUID )."\n" unless $quiet;
    }

    my $JobQ = SMT::JobQueue->new({ 'dbh' => $dbh });

    if ( not $JobQ->deleteJob($jobid, $deleteall ? 'ALL':$GUID) )
    {
        if ($deleteall)
        {
            print sprintf(__("An error occurred when deleting job %s for all guids."), $jobid )."\n" unless $quiet;
        }
        else
        {
            print sprintf(__("An error occurred when deleting job %s for guid %s."), $jobid, $GUID )."\n" unless $quiet;
        }
    }
    else
    {
        print __("Successfully deleted job.")."\n" unless $quiet;
    }
}
else
{
    ## LIST  ##

    print "list\n";
    if ( not defined $JobQ )
    {
        print __("Can not query the job queue.")."\n";
        exit 3;
    }

    if (defined $GUID && defined $jobid)
    {
        print "This is easy - get job $jobid for guid $GUID\n";
        my $res = $JobQ->getJobsInfo(\%query);
        print Data::Dumper->Dump([$res],['res']) if (defined $res);
    }
    else
    {
        $query{'selectAll'} = '';
        my $res = $JobQ->getJobsInfo(\%query);
        print Data::Dumper->Dump([$res],['res']) if (defined $res);

#print Data::Dumper->Dump([\%query],['foo']);
#print Data::Dumper->Dump([\%para],['bar']);

    }   
}




## print debugging output
if (0)
{
    print "\n----------------------------\n";
    print Data::Dumper->Dump([$create], ["create"]);
    print Data::Dumper->Dump([$edit], ["edit"]);
    print Data::Dumper->Dump([$delete], ["delete"]);
    print Data::Dumper->Dump([$list], ["list"]);
    print Data::Dumper->Dump([$targeted], ["targeted"]);
}

exit 0;


#
# Manpage
#

=head1 NAME

smt job

=head1 SYNOPSIS

smt job [options]

=head1 DESCRIPTION

C<smt job> view, create, delete and edit jobs in the SMT job queue.

=head1 OPTIONS

=item --help -h

Show usage for the smt-job command. Lists all available parameters
and time formats used for creating, deleting, editing jobs.

=head1 AUTHORS and CONTRIBUTORS

Jens Daniel Schmidt

=head1 LICENSE

Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
