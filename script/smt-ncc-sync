#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;
use SMT::CLI;
use SMT::Utils;
use SMT::Mirror::RegData;
use SMT::NCCRegTools;
use File::Basename;
use File::Temp;
use Log::Log4perl qw(get_logger :levels);

use Locale::gettext ();
use POSIX ();     # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

#
# FIXME: what about /root/.curlrc for proxy settings?
#
if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

my $mirrorable;
my $domirror;

my $debug   = 0;
my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1;
my $logfile = undef;
my $help    = 0;
my $fromdir = "";
my $todir   = "";
my $exportdir = "";
my $createdbreplfile = "";
my $mail     = 0;
my $mailtempfile = undef;

my $exitcode = 0;

use Getopt::Long;
Getopt::Long::Configure( 'no_auto_abbrev');
my $optres = Getopt::Long::GetOptions(
                                      'fromdir=s'   => \$fromdir,
                                      'todir=s'     => \$todir,
                                      'createdbreplacementfile=s' => \$createdbreplfile,
                                      "logfile|L=s" => \$logfile,
                                      'debug|d'     => \$debug,
                                      "verboselevel|v=i" => \$vblevel,
                                      "mail|m"      => \$mail,
                                      "export=s"    => \$exportdir,
                                      'help|h'      => \$help
                                     );

if ( (defined $help && $help == 1 ) || !$optres )
{
    print basename($0) . " : " . __("Get data from NCC and update the local database.\n\n");
    print __("Usage:\n");
    print basename($0) . " [options]";
    print "\n\n";
    print __("Options:\n");
    print "--fromdir                 ".__("read NCC informations from directory instead of downloading it from NCC\n");
    print "                          ".__("and update the database.\n");
    print "--todir                   ".__("write NCC informations to directory without updating the database.\n");
    print "--createdbreplacementfile ".__("create a database replacement file for using smt-mirror without database.\n");
    print "--logfile -L file         ".__("Path to logfile\n");
    print "--debug                   ".__("Enable debug mode\n");
    print "--verboselevel -v level   ".__("set the verbose level\n");
    print "--export                  ".__("export NCC informations from the local database to a directory of XML files, the\n");
    print "                          ".__("resulting files can be imported on another SMT instance with --fromdir\n");
    print "--mail -m                 ".__("Send output as e-mail to the administrators defined in reportEmail in smt.conf.\n");
    print "                          ".__("The output on stdout and stderr will be suppressed.\n");
  exit 0;
}

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);

if($mail)
{
    my $dir = File::Temp::tempdir("smt-XXXXXXXX", CLEANUP => 1, TMPDIR => 1);
    $mailtempfile = "$dir/mail";
    open(MAILTEMPFILE, "> $mailtempfile") or die "Cannot open file:$!";
    open(STDOUT, ">& MAILTEMPFILE") or die "Cannot dup:$!";
    open(STDERR, ">& MAILTEMPFILE") or die "Cannot dup:$!";
    select STDERR; $| = 1;      # make unbuffered
    select STDOUT; $| = 1;      # make unbuffered
    select MAILTEMPFILE; $| = 1;        # make unbuffered
}

if($createdbreplfile ne "")
{
    SMT::CLI::createDBReplacementFile($createdbreplfile);
    exit 0;
}

if($fromdir ne "" && $todir ne "")
{
    # both options set == no option set
    $fromdir = "";
    $todir   = "";
}

if(!SMT::Utils::openLock("smt-ncc-sync"))
{
    print __("Syncronization process is still running.\n");
    exit 0;
}

# open the logfile
Log::Log4perl::init("/etc/smt.d/log4perl.conf");

# to change the loglevel we need the root logger,
# not the derived main logger
my $log = get_logger('');
$log->level(SMT::Utils::vblevel2log4perl4File($vblevel));
my $out = get_logger('userlogger');
$out->level(SMT::Utils::vblevel2log4perl4Screen($vblevel));

if($fromdir ne "" && $fromdir !~ /^\//)
{
    $fromdir = SMT::Utils::cleanPath($ENV{'PWD'}, $fromdir);
}

if($todir ne "" && $todir !~ /^\//)
{
    $todir = SMT::Utils::cleanPath($ENV{'PWD'}, $todir);
}

if($exportdir ne "" && $exportdir !~ /^\//)
{
    $exportdir = SMT::Utils::cleanPath($ENV{'PWD'}, $exportdir);
}

if($fromdir ne "" && ! -d $fromdir)
{
    $log->fatal("dir '$fromdir' does not exist");
    $out->fatal(sprintf(__("Directory '%s' does not exist."), $fromdir));
    SMT::Utils::unLockAndExit('smt-ncc-sync', 1);
}

if( $exportdir ne "" )
{
    if ( $todir ne "" || $fromdir ne "" )
    {
        $log->fatal('--exportdir used together with --todir or --fromdir');
        $out->fatal(sprintf(
            __("Option '%s' cannot be used together with '%s' or '%s'."),
            '--exportdir', '--todir', '--fromdir'));
        SMT::Utils::unLockAndExit('smt-ncc-sync', 1);
    }
    if ( ! -d $exportdir )
    {
        eval {
                &File::Path::mkpath($exportdir);
        };
        if ($@) 
        {
            $log->fatal('Cannot create $exportdir: $@');
            $out->fatal(sprintf(__("Cannot create %s: %s"), $exportdir, $@));
            SMT::Utils::unLockAndExit('smt-ncc-sync', 1);
        }
    }
}

if($todir ne "" && ! -d $todir)
{
    # directory does not exists, try to create it.
    eval {
        &File::Path::mkpath($todir);
    };
    if ($@) 
    {
        $log->fatal('Cannot create $todir: $@');
        $out->fatal(sprintf(__("Cannot create %s: %s"), $todir, $@));
        SMT::Utils::unLockAndExit('smt-ncc-sync', 1);
    }
}

if ($fromdir)
{
    $log->info('Reading from $fromdir');
    $out->info(sprintf(__("Reading from directory: %s"), $fromdir));
}
if ($todir)
{
    $log->info("Writing to $todir");
    $out->info(sprintf(__("Writing to directory: %s"), $todir));
}

if ($exportdir)
{
    $log->info('Exporting repository information');
    $out->info(__('Exporting repository information'));
    SMT::CLI::db2Xml(outfile => "$exportdir/catalogs.xml",
                     type => "catalogs",
                     table => "Catalogs", 
                     columns => [ 'CATALOGID', 'NAME', 'DESCRIPTION', 'TARGET', 'EXTHOST', 'EXTURL',
                                  'CATALOGTYPE', 'DOMIRROR' ],
                     row_handler => \&catalog_handler
                    );

    $log->info('Exporting product information');
    $out->info(__('Exporting product information'));
    SMT::CLI::db2Xml(outfile => "$exportdir/productdata.xml", 
                     type => "productdata",
                     table => "Products", 
                     columns => [ 'PRODUCTDATAID', 'PRODUCT', 'VERSION', 'REL', 'ARCH', 'FRIENDLY', 
                                  'PARAMLIST', 'NEEDINFO', 'SERVICE', 'PRODUCT_LIST', 'PRODUCT_CLASS' ]
                    );

    $log->info('Exporting product/repository relations');
    $out->info(__('Exporting product/repository relations'));
    SMT::CLI::db2Xml(outfile => "$exportdir/productcatalogs.xml", 
                     type => "productcatalogs",
                     table => "ProductCatalogs", 
                     columns => [ 'PRODUCTDATAID', 'CATALOGID', 'OPTIONAL' ]
                    );

    $log->info('Exporting target information');
    $out->info(__('Exporting target information'));
    SMT::CLI::db2Xml(outfile => "$exportdir/targets.xml", 
                     type => "targets",
                     table => "Targets", 
                     columns => [ 'OS', 'TARGET' ]
                    );

    $log->info('Exporting subscription information');
    $out->info(__('Exporting subscription information'));
    SMT::CLI::db2Xml(outfile => "$exportdir/listsubscriptions.xml", 
                     type => "subscriptionlist",
                     table => "Subscriptions", 
                     columns => [ "SUBID", "REGCODE", "SUBNAME", "SUBTYPE", "SUBSTATUS", 
                                  "SUBSTARTDATE", "SUBENDDATE", "SUBDURATION", "SERVERCLASS", 
                                  "PRODUCT_CLASS" , "NODECOUNT", "CONSUMED", "CONSUMEDVIRT"],
                     row_handler => \&subscriptions_handler );

    # an empty registrations file should be enough for our purposes (later import into 
    # an isolated SMT)
    my $output = new IO::File("> $exportdir/listregistrations.xml");
    if(!defined $output)
    {
        die "Cannot open file '$exportdir/listregistrations.xml':$!";
    }
    my $writer = new XML::Writer(OUTPUT => $output);
    $writer->xmlDecl("UTF-8");
    $writer->startTag("registration", xmlns => "http://www.novell.com/xml/center/regsvc-1_0");
    $writer->endTag("registration");
    $writer->end();
    $output->close();

    SMT::Utils::unLockAndExit('smt-ncc-sync', 0);
}

eval
{
    my $rd= SMT::Mirror::RegData->new(element => "productdata",
                                      table   => "Products",
                                      key     => "PRODUCTDATAID",
                                      fromdir => (($fromdir ne "")?$fromdir:undef),
                                      todir   => (($todir ne "")?$todir:undef));
    $log->info('Downloading product information');
    $out->info(__('Downloading product information'));

    my $res = $rd->sync();
    if ($res)
    {
        $out->error('Error while fetching product data');
        $out->error(__('Error while fetching product data'));
        $exitcode = 1;
    }


    $rd->element("targets");
    $rd->table("Targets");
    $rd->key("OS");

    $log->info('Downloading target information');
    $out->info(__('Downloading target information'));
    $res = $rd->sync();
    if ($res)
    {
        $out->error('Error while fetching target data');
        $out->error(__('Error while fetching target data'));
        $exitcode = 1;
    }

    $rd->element("catalogs");
    $rd->table("Catalogs");
    $rd->key("CATALOGID");

    $log->info('Downloading repository information');
    $out->info(__('Downloading repository information'));
    $res = $rd->sync();
    if ($res)
    {
        $out->error('Error while fetching repository data');
        $out->error(__('Error while fetching repository data'));
        $exitcode = 1;
    }

    $rd->element("productcatalogs");
    $rd->table("ProductCatalogs");
    $rd->key(['PRODUCTDATAID', 'CATALOGID']);
    
    $log->info('Downloading product/repository relations');
    $out->info(__('Downloading product/repository relations'));
    $res = $rd->sync();
    if ($res)
    {
        $out->error('Error while fetching ProductCatalogs data');
        $out->error(__('Error while fetching ProductCatalogs data'));
        $exitcode = 1;
    }
    
    
    my $lr= SMT::NCCRegTools->new(
                                  fromdir => (($fromdir ne "")?$fromdir:undef),
                                  todir   => (($todir ne "")?$todir:undef));

    $log->info('Downloading subscription information');
    $out->info(__('Downloading subscription information'));
    $res = $lr->NCCListSubscriptions();
    if ($res)
    {
        $out->error('Error while fetching subscription data');
        $out->error(__('Error while fetching subscription data'));
        $exitcode = 1;
    }
    
    $log->info('Downloading registration information');
    $out->info(__('Downloading registration information'));
    $res = $lr->NCCListRegistrations();
    if ($res)
    {
        $out->error('Error while fetching registration data');
        $out->error(__('Error while fetching registration data'));
        $exitcode = 1;
    }
    
    if ($todir ne "")
    {
        SMT::CLI::setMirrorableCatalogs(todir   => $todir);
        # if todir parameter is set, we can stop here. Everything is done.
        SMT::Utils::unLockAndExit('smt-ncc-sync', 0);
    }
    
    $log->info('Flagged repositories which can be mirrored');
    $out->info(__('Flagged repositories which can be mirrored'));
    SMT::CLI::setMirrorableCatalogs(fromdir => ($fromdir ne "")?$fromdir:undef,
                                    todir   => ($todir ne "")?$todir:undef);
    if( $fromdir && -d $fromdir )
    {
        my $mirrorinfofile = $fromdir."/mirrorinfo.xml";
        if ( -f $mirrorinfofile && (stat($fromdir."/catalogs.xml"))[9] <= (stat($mirrorinfofile))[9] )
        {
            $out->info("Updating mirror flags from $mirrorinfofile.");
            $out->info(sprintf(__("Updating mirror flags from '%s'."), $mirrorinfofile));
            SMT::CLI::setDoMirrorFromXml( xml => $mirrorinfofile );
        }
    }
    
};
if ($@)
{
    $log->error($@);
    $out->error($@);
    $exitcode = 1;
}

if($mail)
{
    close (STDERR);
    close (STDOUT);
    close (MAILTEMPFILE);
    my $body = "";
    
    open(MAIL, "< $mailtempfile") and do
    {
        while(<MAIL>)
        {
            $body .= $_;
        }
        close MAIL;
    };
    my $datestring = POSIX::strftime("%Y-%m-%d %H:%M", localtime);
    my $subject = sprintf("SMT Sync Report $datestring (%s) -- Sync %s",
                          SMT::Utils::getFQDN(), (($exitcode > 0)?"failed":"successful"));

    SMT::Utils::sendMailToAdmins($subject, $body);
}

SMT::Utils::unLockAndExit('smt-ncc-sync', $exitcode);

sub subscriptions_handler
{
    my ($writer,$row) = @_;
    # The SQL column name don't map 1to1 to the XML tag names for the Subscriptions-Table
    my %col2tag = ( 
        "SUBID"         => "subid",
        "REGCODE"       => "regcode",
        "SUBNAME"       => "subname",
        "SUBTYPE"       => "type",
        "SUBSTATUS"     => "substatus",
        "SUBSTARTDATE"  => "start-date",
        "SUBENDDATE"    => "end-date",
        "SUBDURATION"   => "duration",
        "SERVERCLASS"   => "server-class",
        "PRODUCT_CLASS" => "product-class",
        "NODECOUNT"     => "nodecount",
        "CONSUMED"      => "consumed",
        "CONSUMEDVIRT"  => "consumed-virtual"
    );
    $writer->startTag("subscription");
    foreach my $col (keys %{$row})
    {
        $writer->startTag($col2tag{$col});
        $writer->characters( $row->{$col} ?  $row->{$col} : "0");
        $writer->endTag($col2tag{$col});
    }
    $writer->endTag("subscription");
}

sub catalog_handler
{
    my ($writer,$row) = @_;
    $writer->startTag("row");
    foreach my $col (keys %{$row})
    {
        $writer->startTag("col", name => ( $col eq "DOMIRROR" ? "MIRRORABLE" : $col ));
        $writer->characters($row->{$col});
        $writer->endTag("col");
    }
    $writer->endTag("row");
}


# need for Log4perl::init()
sub logfile
{
  return $logfile if ($logfile);
  return "/var/log/smt/smt-ncc-sync.log";
}


#
# Manpage
#

=head1 NAME

smt ncc-sync -  

=head1 SYNOPSIS

smt ncc-sync [options]

=head1 DESCRIPTION

C<smt ncc-sync> gets data from Novell Customer Center and updates the local database.

=head1 OPTIONS

=head2 COMMANDLINE

=over

=item --fromdir directory

Reads NCC information from directory instead of downloading it from NCC and update the database.

=item --todir directory

Write NCC informations to directory without updating the database.

=item --createdbreplacementfile

Creates a database replacement file for using smt-mirror without database.

=item --logfile -L file

Path to logfile.

=item --debug

Enable display of debug information.

=item --mail -m

Send output as e-mail to the administrators defined in reportEmail in smt.conf .
The output on stdout and stderr will be suppressed in this mode.

=item --export directory

Export the NCC informations from the local database to a directory of XML files,
that directory can later be imported on another SMT instance with 
C<smt ncc-sync --fromdir directory>.

=back

=head1 AUTHORS and CONTRIBUTORS

Duncan Mac-Vicar Prett, Lukas Ocilka, Jens Daniel Schmidt, Michael Calmer

=head1 LICENSE

Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
