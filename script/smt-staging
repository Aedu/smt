#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use Getopt::Long;
use File::Basename;
use Text::ASCIITable;
use Date::Format;
use RPMMD::Tools::Mirror;
use RPMMD::Tools::DepChecker;
use RPMMD::Filter;
use RPMMD::Parser::Updates;
use Log::Log4perl qw(get_logger :levels);

use SMT;
use SMT::Utils;
use SMT::Repositories;
use SMT::Mirror::Utils;
use SMT::Mirror::Yum;

my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2;
my $debug    = 0;
my $logfile = undef;
my $help     = 0;

my $dbreplfile = undef;
my $dbreplacement = [];

my $gentest = 0;
my $genprod = 0;
my $nohardlink = 0;

my @userpatches = ();
my $category = undef;
my $individually = 0;

my $all = 0;
my $nodesc = 0;
my $sortbyversion = 0;
my $sortbycategory = 0;

# these are for signing the testing/production snapshots, if changed
my $keyid = undef;
my $keypass = undef;

my $optres = GetOptions("testing|t"    => \$gentest,
                        "production|p" => \$genprod,
                        "nohardlink"   => \$nohardlink,
                        "patch=s"      => \@userpatches,
                        "category=s"   => \$category,
                        "individually|i" => \$individually,
                        "all|a"        => \$all,
                        'nodesc'       => \$nodesc,
                        'sort-by-version' => \$sortbyversion,
                        'sort-by-category' => \$sortbycategory,
                        'keyid=s'      => \$keyid,
                        'keypass=s'    => \$keypass,

                        "dbreplfile=s" => \$dbreplfile,

                        "debug|d"      => \$debug,
                        "verboselevel|v=i" => \$vblevel,
                        "logfile|L=s"  => \$logfile,
                        "help|h"       => \$help,
                       );

sub printhelp
{
    my $scriptname = shift;

    print $scriptname . " status <repository>\n";
    print $scriptname . " listupdates <repository>\n";
    print "    [--patch <patch> ... | --category <category>] [--nodesc]\n";
    print "    [--sort-by-version | --sort-by-category]\n";
    print "\n";
    print $scriptname . " forbid <repository>\n";
    print "    [--patch <patch> ... | --category <category> | --all]\n";
    print "    [--individually]\n";
    print "\n";
    print $scriptname . " allow <repository>\n";
    print "    [--patch <patch> ... | --category <category> | --all]\n";
    print "    [--individually]\n";
    print "\n";
    print $scriptname . " createrepo <repository>\n";
    print "    --testing|--production [--nohardlink] [--keyid ID [--keypass password]] \n";
    print "\n";
    print $scriptname . " --help | -h\n";
    print "\n";
    print __("Repository can be specified using its name and target or ID\n");
    print __("from 'smt-repos' output. See 'man smt-staging' for more deails.\n");
    print "\n";
    print __("Options:\n");
    print "--testing          (-t) " . __("Generate testing repository with selected updates.\n");
    print "--production       (-p) " . __("Generate production repository with selected updates.\n");
    print "--patch <name-ver>      " . __("Specify patch to forbid or allow using name and version.\n");
    print "--category <category>   " . __("Specify patch category to forbid or allow.\n");
    print "                        " . __("Choose one of: recommended, security, optional.\n");
    print "--nodesc                " . __("Do not print summaries and descriptions of udpates.\n");
    print "--sort-by-version       " . __("Sort patch list by patch version.\n");
    print "--sort-by-category      " . __("Sort patch list by patch category.\n");
    #print "--hardlink size         " . __("Search for duplicate files with size > 'size' (in Kilobytes) and create hardlinks\n");
    #print "                        " . __("for them\n");
    print "--nohardlink            " . __("If a file already exists on local filesystem, do not\n");
    print "                        " . __("link it into the mirrored repository. Copy it instead.\n");
    print "--debug            (-d) " . __("Enable debug mode.\n");
    print "--verboselevel     (-v) " . __("Set the level of verbosity.\n");
    print "--logfile <file>   (-L) " . __("Log to specified file.\n");
}

if ($help || !$optres)
{
    printhelp(basename($0));
    exit 0;    
}

if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

$SIG{INT}  = \&signal_handler;
$SIG{TERM} = \&signal_handler;

if (@ARGV < 2)
{
    print STDERR __("Too few arguments. At least a command and repository ID are required.\n");
    print "\n";
    printhelp(basename($0));
    exit 1;
}

# the first non-option argument is the command

my $command = undef;
if (not
    $ARGV[0] eq 'createrepo' ||
    $ARGV[0] eq 'status' ||
    $ARGV[0] eq 'listupdates' ||
    $ARGV[0] eq 'forbid' ||
    $ARGV[0] eq 'allow')
{
    printf STDERR __("Unknown command '%s'\n"), $ARGV[0];
    print "\n";
    printhelp(basename($0));
    exit 1;
}
else
{
    $command = shift @ARGV;
}

# the second is the repository id or name (if there is the third argument)
my $reponameid = shift @ARGV;

# the third (optional) is always the repository target (from the smt-repos output)
my $target = shift @ARGV;

# get a lock

if(!SMT::Utils::openLock("smt-staging"))
{
    print __("Other staging process is still running.\n");
    exit 0;
}

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);

# open the logfile
Log::Log4perl::init("/etc/smt.d/log4perl.conf");

# to change the loglevel we need the root logger,
# not the derived main logger
my $log = get_logger('');
$log->level(SMT::Utils::vblevel2log4perl4File($vblevel));
my $out = get_logger('userlogger');
$out->level(SMT::Utils::vblevel2log4perl4Screen($vblevel));

# register RPMMD callback handlers
RPMMD::Callbacks::instance()->setMirrorReporter(\& mirrorReportHandler);
RPMMD::Callbacks::instance()->setMirrorJobReporter(\& mirrorJobReportHandler);

# get the config

my $cfg = undef;
eval
{
    $cfg = SMT::Utils::getSMTConfig();
    # pass config to RPMMD
    SMT::Utils::smt2RpmmdConfig($cfg);
};
if($@ || !defined $cfg)
{
    $log->fatal("Cannot read the SMT configuration file: $@");
    $out->fatal(sprintf(__("Cannot read the SMT configuration file: %s"), $@));
    SMT::Utils::unLockAndExit('smt-mirror', 1);
}

# connect to database (all commands need it)

my $dbh = SMT::Utils::db_connect();
if(!$dbh)
{
    $log->fatal('Cannot connect to database.');
    $out->fatal(__("Cannot connect to database."));
    SMT::Utils::unLockAndExit('smt-mirror', 1);
}

# get the repository from DB (all commands need it)

my $rh = SMT::Repositories::new($dbh, $log);
my $repo = $rh->getRepository($reponameid) if (not defined $target);
my $repoid = undef;
$rh->getAndClearErrorMessage();

if (not defined $repo)
{
    if (not defined $target)
    {
        # not found by CATALOGID, lets try by ID (row number) from smt-repos

        my $repos = $rh->getAllRepositories();
        my $err = $rh->getAndClearErrorMessage();
        my $count = scalar keys %$repos;

        $log->error('DB error: ' . $err) if ($err);

        if ( $reponameid =~ /^[0-9]+$/ &&
            int($reponameid) > 0 && int($reponameid) <= $count)
        {
            my $id = 1;
            foreach my $r (keys %$repos)
            {
                if ($repos->{$r}->{rownr} == int($reponameid))
                {
                    $repo = $repos->{$r};
                    $repoid = $r;
                    last;
                }
                $id++;
            }
        }
        else
        {
            $log->error(sprintf("Repository ID '%s' not found.", $reponameid));
            $out->error(sprintf(__("Repository ID '%s' not found."), $reponameid));
            $out->info(sprintf(__("Use '%s' to list all available repositories.\n"), 'smt-repos'));
            SMT::Utils::unLockAndExit( "smt-staging", 1);
        }
    }
    # try to find by name & target
    else
    {
        my $repos = $rh->getAllRepositories({
            SMT::Repositories::NAME => $reponameid,
            SMT::Repositories::TARGET => $target
        });

        my $count = scalar keys %$repos;
        if ($count <= 0)
        {
            $out->error(sprintf("Repository named '%s' with target '%s' not found.", $reponameid, $target));
            $out->error(sprintf(__("Repository named '%s' with target '%s' not found."), $reponameid, $target));
            $out->info(printf(__("Use '%s' to list all available repositories.\n"), 'smt-repos'));
            SMT::Utils::unLockAndExit('smt-staging', 1);
        }
        elsif ($count == 1)
        {
            my @k = keys %$repos;
            $repo = $repos->{$k[0]};
            $repoid = $k[0];
        }
        else
        {
            # select manually
            $log->error(sprintf("Multiple repositories named '%s' with target '%s' found.", $reponameid, $target));
            $out->error(sprintf(__("Multiple repositories named '%s' with target '%s' found."), $reponameid, $target));
            $out->info(__('Selection from multiple repositories is not implemented. Use repository ID.'));
            SMT::Utils::unLockAndExit('smt-staging', 1);
        }
    }
}
else
{
    $log->debug(sprintf("Found repository by CATALOGID '%s'.", $reponameid));
    $repoid = $reponameid;
}

# $repo and $repoid should always be defined at this point

if ($repo->{STAGING} ne 'Y')
{
    $log->fatal(
        sprintf("Staging is not enabled for repository '%s', target '%s'.",
            $repo->{NAME}, $repo->{TARGET}));
    $out->fatal(
        sprintf(__("Staging is not enabled for repository '%s', target '%s'."),
            $repo->{NAME}, $repo->{TARGET}));
    $out->info(
        sprintf(__('Use "%s" to enable staging for this repository.'),
            'smt repos \'' . $repo->{NAME} . '\' \'' . $repo->{TARGET} . '\' -s'));
    SMT::Utils::unLockAndExit('smt-staging', 1);
}

# now we're ready to do the real work

my $basepath = $cfg->val("LOCAL", "MirrorTo");
my $localfullrepopath = SMT::Utils::cleanPath(
    $basepath, "repo/full", $repo->{LOCALPATH});
my $localtestingrepopath = SMT::Utils::cleanPath(
    $basepath, $rh->getTestingRepoPath($repoid)); 
my $localproductionrepopath = SMT::Utils::cleanPath(
    $basepath, $rh->getProductionRepoPath($repoid)); 


# list of known patch categories
my %exists_category = (
    'recommended'   => 1,
    'security'      => 1,
    'optional'      => 1);

###############################################################################
# testing/production repository status
###############################################################################

if ($command eq 'status')
{
    my $filter = RPMMD::Filter->new();
    $filter->dbload($dbh, $SMT::FILTER_DBATTRS, $repo->{ID});

    print __('Reading patches...') . "\n";

    print "\n";
    print __('Repository:          ') . $repo->{NAME} . "\n";
    print __('Target:              ') . $repo->{TARGET} . "\n";

    my $fstatus = SMT::Mirror::Utils::getStatus($localfullrepopath);
    my $tstatus = SMT::Mirror::Utils::getStatus($localtestingrepopath);
    my $pstatus = SMT::Mirror::Utils::getStatus($localproductionrepopath);

    print __('Last mirrored:       ');
    if (!$fstatus)
    {
        print __('never')
    }
    else
    {
        print $repo->{LAST_MIRROR}
    }
    print "\n";

    print __('Testing snapshot:    ');
    if (!$tstatus)
    {
        print __('not created')
    }
    else
    {
        print sprintf __('created (corresponding mirror date: %s)'),
                        time2str('%Y-%m-%d %T', $tstatus)
    }
    print "\n";

    print __('Production snapshot: ');
    if (!$pstatus)
    {
        print __('not created')
    }
    else
    {
        print sprintf __('created (corresponding mirror date: %s)'),
                        time2str('%Y-%m-%d %T', $pstatus)
    }
    print "\n";

    my $parser = RPMMD::Parser::Updates->new();
    $parser->resource($localfullrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");

    print "\n";
    printPatchCounts($patches, $filter);
}

###############################################################################
# list the udates
###############################################################################

elsif ($command eq 'listupdates')
{
    if (defined $category && not $exists_category{$category})
    {
        $log->fatal("Invalid category '$category'.");
        $out->fatal(sprintf(__("Invalid category '%s'."), $category));
        $out->fatal(sprintf(__("See '%s' for the list of known categories."), 'man smt-staging'));
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    # read filters
    my $filter = RPMMD::Filter->new();
    $filter->dbload($dbh, $SMT::FILTER_DBATTRS, $repo->{ID});

    # read patches from all repos

    my $parser = RPMMD::Parser::Updates->new(log => $log, vblevel => $vblevel);
    $parser->resource($localfullrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");

    my $testpatches = {};
    if (SMT::Mirror::Utils::getStatus($localtestingrepopath))
    {
        $parser->resource($localtestingrepopath);
        $testpatches = $parser->parse("repodata/updateinfo.xml.gz");
    }

    my $prodpatches = {};
    if (SMT::Mirror::Utils::getStatus($localproductionrepopath))
    {
        $parser->resource($localproductionrepopath);
        $prodpatches = $parser->parse("repodata/updateinfo.xml.gz");
    }


    if (@userpatches)
    {
        if (defined $category)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--category', '--patch') . "\n";
        }
        
        foreach (@userpatches)
        {
            if (not defined $patches->{$_})
            {
                $log->warn("Patch '$_' not found.");
                $out->warn(sprintf(__("Patch '%s' not found."), $_));
                next;
            }

            my $patch = $patches->{$_};

            my $allowed = not $filter->matches($patch);
            my $testing = undef;
            if (defined $testpatches->{$_})
            {
                $testing = __('Yes');
                $testing .= ' (' . __('scheduled to be removed') . ')'
                    if (not $allowed);
            }
            else
            {
                $testing =  __('No');
                $testing .= ' (' . __('scheduled to be added') . ')'
                    if ($allowed);
            }
            my $production = defined $prodpatches->{$_} ? __('Yes') : __('No');

            print $_ . "\n";
            print (('-' x length $_) . "\n");
            my $ident = '    ';
            print $ident . __('Name: ') . $patch->{name} . "\n";
            print $ident . __('Version: ') . $patch->{version} . "\n";
            print $ident . __('Category: ') . $patch->{type} . "\n";
            print $ident . __('Summary: ') . $patch->{title} . "\n";
            print $ident . __('Is In Testing: ') . $testing . "\n";
            print $ident . __('Is In Production: ') . $production . "\n";

            if (not $allowed)
            {
                print $ident . __('Filtered by:') . "\n";
                print $filter->whatMatches2str($patch, 4) . "\n";
            }

            print $ident . __('Description: ') . "\n" .
                $patch->{description} . "\n\n"
                    if (not $nodesc);
        }
    }
    else
    {
        my @cols = (
            __("T"),
            __("P"),
            __("Name"), 
            __("Version"),
            __("Category")
        );
        push @cols, __("Summary") if (not $nodesc);

        my $t = new Text::ASCIITable;
        $t->setCols(@cols);

        my @sorted = ();
        if ($sortbyversion)
        {
            @sorted =
                sort { $patches->{$a}->{version} <=> $patches->{$b}->{version} }
                keys %$patches;
        }
        elsif ($sortbycategory)
        {
            @sorted =
                sort { $patches->{$a}->{type} cmp $patches->{$b}->{type} }
                keys %$patches;
        }
        else # sort by name
        {
            @sorted = sort { $a cmp $b } keys %$patches;
        }

        foreach my $id (@sorted)
        {
            next if ($category && $patches->{$id}->{type} ne $category);

            # a/f/+/-
            my $testing = undef;
            if ($filter->matches($patches->{$id}))
            { $testing = defined $testpatches->{$id} ? '-' : __('f') }
            else
            { $testing = defined $testpatches->{$id} ? __('a') : '+' }

            my @row = (
                $testing,
                defined $prodpatches->{$id} ? __('a') : __('f'),
                $patches->{$id}->{name},
                $patches->{$id}->{version},
                $patches->{$id}->{type}
            );
            push @row, $patches->{$id}->{title} if (not $nodesc);
            $t->addRow(@row); 
        }
        if (%$patches)
        {
            print $t->draw();
        }
        else
        {
            print __("This repository does not contain any patches.") . "\n";
        }
    }
}


###############################################################################
# allow/forbid an update
###############################################################################

elsif ($command eq 'allow' || $command eq 'forbid')
{
    my $canfilter = canFilter($repoid, $basepath);
    SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel )
        if (defined $canfilter && not $canfilter);

    my $filter = RPMMD::Filter->new();
    $filter->dbload($dbh, $SMT::FILTER_DBATTRS, $repo->{ID});

    my $parser = RPMMD::Parser::Updates->new();
    $parser->resource($localfullrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");

    my $allow = $command eq 'allow';

    printPatchCounts($patches, $filter);

    if (@userpatches)
    {
        if (defined $category)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--category', '--patch') . "\n";
        }
        if ($all)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--all', '--patch') . "\n";
        }
        my $count = 0;
        foreach (@userpatches)
        {
            # make sure user gave an existing patch
            if (not defined $patches->{$_})
            {
                $log->warn("Patch '$_' not found.");
                $out->warn(sprintf(__("Patch '%s' not found."), $_));
                next;
            }

            if ($allow)
            {
                $filter->remove(RPMMD::Filter->TYPE_NAME_VERSION, $_);
                if ($filter->matches($patches->{$_}))
                {
                    my $matches = $filter->whatMatches2str($patches->{$_});
                    $log->warn("Patch '$_' is still filtered by:\n$matches");
                    $out->warn(
                        sprintf (__("Patch '%s' is still filtered by:\n%s"),
                            $_, $matches));
                }
            }
            else
            {
                $filter->add(RPMMD::Filter->TYPE_NAME_VERSION, $_)
            }
        }
    }
    elsif (defined $category)
    {
        if ($all)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--all', '--category') . "\n";
        }
        if ($exists_category{$category})
        {
            if ($allow)
            {
                print sprintf (
                    __('Removing filter by category \'%s\'.'), $category) . "\n";

                $filter->remove(RPMMD::Filter->TYPE_PATCH_CATEGORY, $category);
                if ($individually)
                {
                    print sprintf (
                        __('Allowing all \'%s\' patches individually.'), $category) . "\n";
                    for (keys %$patches)
                    {
                        $filter->remove(RPMMD::Filter->TYPE_NAME_VERSION, $_)
                            if ($patches->{$_}->{type} eq $category);
                    }
                }
                else
                {
                    my @stillfiltered = ();
                    for (keys %$patches)
                    {
                        push @stillfiltered, $_
                            if ($filter->matches($patches->{$_}))
                    }
    
                    if (@stillfiltered)
                    {
                        print __('The following patches are still filtered by other means than category:') . "\n";
                        print $_ . "\n" for (@stillfiltered);
                        print sprintf (__('Use "%s" to see details.'),
                                'smt staging listupdates ' . $repoid .
                                ' --patch <patchname-version>') . "\n";
                        print sprintf (
                            __('Use "%s" to alow all these patches individually.'),
                            'smt staging allow ' . $repoid .
                            ' --category ' . $category . ' --individually');
                        print "\n";
                    }
                }
            }
            else
            {
                if ($individually)
                {
                    print sprintf (
                        __('Forbidding all \'%s\' patches individually.'), $category) . "\n";
                    for (keys %$patches)
                    {
                        $filter->add(RPMMD::Filter->TYPE_NAME_VERSION, $_)
                            if ($patches->{$_}->{type} eq $category);
                    }
                }
                else
                {
                    print sprintf (
                        __('Adding filter by category \'%s\'.'), $category) . "\n";
                    $filter->add(RPMMD::Filter->TYPE_PATCH_CATEGORY, $category);
                }
            }
        }
        else
        {
            $log->fatal("Invalid category '$category'.");
            $out->(sprintf(__("Invalid category '%s'."), $category));
            $out->(sprintf(__("See '%s' for the list of known categories."), 'man smt-staging'));
            SMT::Utils::unLockAndExit('smt-staging', 1);
        }
    }
    elsif (defined $all)
    {
        if ($allow)
        {
            $filter->clean();
            $log->info('All patches have been allowed.');
            $out->info(__('All patches have been allowed.'));
        }
        else
        {
            # remove all filters first, then forbid all, individually
            $filter->clean(); 
            $filter->add(RPMMD::Filter->TYPE_NAME_VERSION, $_)
                foreach (keys %$patches);
            
            my $pcount = scalar keys %$patches;
            $log->info("All $pcount patches have been forbidden.");
            $out->info(
                sprintf (__('All %d patches have been forbidden.'), $pcount));
        }
    }
    else
    {
        $log->fatal('No patches specified.');
        $out->info(__('Specify at least one \'--patch name-version\'.'));
        $out->info(__('Use \'smt-staging listupdates\' to see the list of available patches.'));
        SMT::Utils::unLockAndExit('smt-staging', 1);
    }

    # check consistency of the resulting repository before applying changes
    if ($filter->dirty() && not $all)
    {
        my $checker = RPMMD::Tools::DepChecker->new(
            log => $log, vblevel => $vblevel); 
        $checker->repoPath($localfullrepopath);
        $checker->filter($filter);
        $out->info(__('Checking repository consistency...'));
        my ($result, $problems, $causes) = $checker->check();
        $log->info('DONE checking dependencies');

        if (not $result)
        {
            $out->error(__("Dependecy problems found."));

            foreach my $pkg (keys %$problems)
            {
                $log->error("Cannot remove '$pkg' required by forbidden patch " . $causes->{$pkg});
                $out->error(sprintf(
                    __("Cannot remove package '%s' required by forbidden patch '%s'."),
                    $pkg, $causes->{$pkg}));
    
                $log->error(
                    'The package is needed by allowed patch '.$causes->{$pkg});
                $out->error(sprintf(
                    __("The package is needed by patch '%s', which is allowed."),
                    $problems->{$pkg}));
            }
    
            SMT::Utils::unLockAndExit('smt-staging', 1);
        }
        else
        {
            $out->info(__("OK"));
        }
    }

    $filter->dbsave($dbh, $SMT::FILTER_DBATTRS, $repo->{ID});

    print "\n";
    printPatchCounts($patches, $filter);
}

###############################################################################
# create testing/production repo
###############################################################################

elsif ($command eq 'createrepo')
{
    if ($gentest && $genprod)
    {
        $log->fatal('--testing and --production used together');
        $out->fatal(sprintf(__("Options %s and %s cannot be used together."), '--testing', '--production'));
        SMT::Utils::unLockAndExit('smt-staging', 1);
    }
    elsif (!($gentest || $genprod))
    {
        $log->fatal('neither --testing nor --production given');
        $out->fatal(sprintf(__("%s or %s?"), '--testing', '--production'));
        SMT::Utils::unLockAndExit('smt-staging', 1);
    }

    my $mirrorsrc = $cfg->val("LOCAL", "MirrorSRC");
    if (defined $mirrorsrc && lc($mirrorsrc) eq "false")
    { $mirrorsrc = 0; }
    else
    { $mirrorsrc = 1; }

    # source

    my $sourcerepourl = 'file://';
    if ($gentest)
    {
        $sourcerepourl .= $localfullrepopath;
    }
    else
    {
        if (not -e $localtestingrepopath . '/repodata/repomd.xml' &&
            SMT::Mirror::Utils::getStatus($localtestingrepopath))
        {
            $log->fatal('No testing repo, cannot generate production');
            $out->fatal(
                __('Testing repository does not exist or is not generated properly, cannot generate production repository.'));
            $out->info(__('Generate the testing repository first.'));
            SMT::Utils::unLockAndExit('smt-staging', 1);
        }
        # always generate the production repo from the testing repo
        $sourcerepourl .= $localtestingrepopath;
    }

    # target

    my $localtargetrepopath = ($gentest ?
        $rh->getTestingRepoPath($repoid) :
        $rh->getProductionRepoPath($repoid));


    my $filter = RPMMD::Filter->new();
    $filter->dbload($dbh, $SMT::FILTER_DBATTRS, $repo->{ID});

    my $mirror = undef;
    if ( exists $repo->{CATALOGTYPE} && defined $repo->{CATALOGTYPE} &&
         lc($repo->{CATALOGTYPE}) eq "yum")
    {
        $mirror = SMT::Mirror::Yum->new(
            dbh        => $dbh,
            cfg        => $SMT::MIRROR_CFG,
            filter     => $gentest ? $filter : undef,
            nohardlink => $nohardlink,
            mirrorsrc  => $mirrorsrc);
    }
    else
    {
        $mirror = RPMMD::Tools::Mirror->new(
            dbh        => $dbh,
            cfg        => $SMT::MIRROR_CFG,
            filter     => $gentest ? $filter : undef,
            nohardlink => $nohardlink,
            mirrorsrc  => $mirrorsrc);
    }


    $mirror->uri($sourcerepourl);
    $mirror->localBasePath($basepath);
    $mirror->localRepoPath($localtargetrepopath);

    if (not defined $keyid)
    {
        $keyid = $cfg->val('LOCAL', 'signingKeyID');
        if ($keyid)
        {
            $log->debug('Using key ID ' . $keyid . ' from smt.conf\'s signingKeyID');
        }
    }

    if ($gentest && $keyid && not defined $keypass)
    {
        print __('Signing key passphrase: ');
        system("stty -echo");
        $keypass = <STDIN>;
        chomp $keypass;
        print "\n";
        system("stty echo");
    }

    my $errcnt = $mirror->mirror(force => 1, keyid => $keyid, keypass => $keypass);
    if ($errcnt)
    {
        $out->fatal(_('Repository generatino failed.'));
        SMT::Utils::unLockAndExit('smt-staging', 1);
    }
    else
    {
        SMT::Mirror::Utils::copyStatus(
            $genprod ? $localtestingrepopath : $localfullrepopath,
            SMT::Utils::cleanPath($basepath, $localtargetrepopath));
        $out->info(sprintf(
            __("Repository successfully generated at %s."), $localtargetrepopath));
        $log->info('repo generated ok');
    }
}

SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );

sub printPatchCounts
{
    my ($patches, $filter) = @_;
    my $forbidden = 0;
    my $allowed = 0;
    foreach (values %$patches)
    {
        if ($filter->matches($_))
        { $forbidden++ }
        else
        { $allowed++ }
    }
    $log->info("patches allowed: $allowed, forbidden: $forbidden, total: "
        . $forbidden + $allowed);
    $out->info(sprintf (__("Total patches: %d"), $forbidden + $allowed));
    $out->info(sprintf (__("Allowed:       %d"), $allowed));
    $out->info(sprintf (__("Forbidden:     %d"), $forbidden));
}

# check if we can do filtering for this repo
sub canFilter
{
    my ($repoid, $basepath) = @_;
    my $canfilter = $rh->filteringAllowed($repoid, $basepath);
    if (not defined $canfilter)
    {
        $out->warn(sprintf(
            __("Cannot determine whether filtering is allowed for repository '%s', target '%s'."),
                $repo->{NAME}, $repo->{TARGET}));
        $out->info(__('See the log for more details.'));
        $out->info(__('Trying to proceed anyway.'));
        $log->info('can filter: uknown, continuing anyway');
    }
    elsif (!$canfilter)
    {
        $log->info('can filter: ' . $canfilter);
        $out->info(sprintf(
            __("Filtering is not allowed for repository '%s', target '%s'."),
            $repo->{NAME}, $repo->{TARGET}));
        $out->info(__('The repository either does not contain update metadata, or the metadata are in an unsupported format.'));
        $out->info(__('Only openSUSE 11.x, SLE-11, and Fedora/RedHat update repositories are supported.'));
    }
    return $canfilter;
}

sub signal_handler
{
  $log->info('Interrupted by signal. Exiting.');
  $out->info(__('Interrupted by signal. Exiting.'));
  SMT::Utils::unLockAndExit('smt-mirror', 1);
}

# RPMMD::Tools::Mirror callback handler
sub mirrorReportHandler
{
  my ($rtype, $level, $msg, $pg) = @_;
  $out->log($level, $msg) if ($msg);
}

# RPMMD::Tools::MirrorJob callback handler
sub mirrorJobReportHandler
{
  my ($rtype, $level, $msg, $pg) = @_;
  $out->log($level, $msg) if ($msg);
}

# need for Log4perl::init()
sub logfile
{
  return $logfile if ($logfile);
  return "/var/log/smt/smt-report.log";
}


#
# Manpage
#

=head1 NAME

smt staging

=head1 SYNOPSIS

smt staging <command> <repository> [options]

smt staging status <repository> [general-options]

smt staging listupdates <repository> [general-options]
    [--patch <patch> ... | --category <category>] [--nodesc]
    [--sort-by-version | --sort-by-category]

smt staging forbid <repository> [general-options]
    [--patch <patch> ... | --category <category> | --all]
    [--individually]

smt staging allow <repository> [general-options]
    [--patch <patch> ... | --category <category> | --all] [--individually]
    [--individually]

smt staging createrepo <repository> [general-options]
    --testing|--production [--nohardlink]

smt staging --help | -h

=head1 DESCRIPTION

C<smt staging> script allows setting up patch (update) filters for update
repositories and generate repositories for testing or use in production
environment.

Use the B<listupdates> command to list available patches and their
allowed/forbidden status, B<allow>/B<forbid> commands to allow or forbid
specified patches, and, finally B<createrepo> to generate testing or production
repository containing only allowed patches. The B<status> command gives
information about testing and production snapshots up-to-date status and patch
counts.

=head1 TERMINOLOGY

=over 4

=item patch

An update of a package or group of packages. The term I<update> and I<patch> are
interchangable throughout this manual and in the C<smt staging> script. 

=back

=head1 ARGUMENTS

The first argument of C<smt staging> is always the B<command>. The command must
be followed by I<repository>. Repository can be specified using the I<ID> or
I<Name and Target> from the table returned by C<smt repos>. The third alternative
is to use the hexadecimal I<Repository ID> found in C<smt repos -v> output.

Examples:

=over 4

=item $ smt staging createrepo 1 --testing

creates testing repository from repository number 1 from C<smt repos> table.

=item $ smt staging listupdates SLED10-SP1-Updates sled-10-i586

lists patches from SLED10-SP1-Updates repository for sled-10-i586. Use
C<smt repos> to get a list of all repository names and targets.


=back

=head1 RECOMMENDED WORKFLOW

 1) Enable staging for the desired repository
    $ smt repos -s
 2) Mirror the remote repository (you can get the ID from C<smt repos -v>)
    $ smt mirror [--repository Repostiory_ID]
 3) See available patches
    $ smt staging listupdates <Repository_ID> [--patch <patchid>]
 4) Allow/forbid the desired patches by their ID or Category
    $ smt staging allow <Repository_ID> --patch foo-312
 5) Recheck which patches are allowed/forbidden
    $ smt staging listupdates <Repository_ID> --nodesc
 6) Create the testing repository
    $ smt staging createrepo <Repository_ID> --testing [--keyid <keyid>]
 7) Test installation and functionality of the patches in testing clients
 8) If no problems were discovered during the testing, create the production
    repository
    $ smt staging createrepo <Repository_ID> --production [--keyid <keyid>]
 9) Update your production clients or monitor them as they update automatically


=head1 GENERAL OPTIONS

The following options apply to any command.

=over 4

=item -L, --logfile <filepath>

Write log to the specified file. If the file does not exist, it will be
created. 

=item -d, --debug

Turn on debugging output and log.

=item -v, --verbose 

Enable more detailed output.

=back

=head1 COMMANDS

=over 4

=item status

Shows the date and time of the last mirroring of the full repository and status
of the testing and production repository, plus some other information.

The testing and production repository status is determined by the date of the
full mirror from which the testing (and then production) repository was created.
The output is as follows:
 'not created'
    the repository has not ever been (successfully) created
 'created (corresponding mirror date: YYYY-MM-DD hh:mm:ss)'
    meaning the repository has been successfully created from the full mirror
    which was mirrored on the shown date. 

=item listupdates

Lists all available patches and marks their presence in the testing
and production repositories. When specific patches are specified via the
I<--patch> options, detailed information is shown for these patches.

The output table contains the follwing columns:
 T - whether the patch is or is scheduled to be in the testing repository.
     The following values can be found in this column:
     a - (allowed) the patch is in the testing repository
     f - (forbidden) the patch is not in the testing repository
     + - the patch is scheduled to be added to the testing repository
     - - the patch is scheduled to be removed from the testing repository
 P - whether the patch is in the production repository. Possible values:
     a - (allowed) the patch is in the production repository
     f - (forbidden) the patch is not in the production repository
 Name     - patch name
 Version  - patch version
 Category - patch category (security, recommended, or optional)
 Summary  - brief summary of the issues the patch fixes. This column can be
            hidden from view using the I<--nodesc> option.

Use the I<--sort-by-*> options to sort the table by version or category. Default
sorting is by patch name.

The detailed output (shown when I<--patch> is specified) contains additional
information like which properties are used to filter (forbid) the patch,
full description, etc.

=item allow/forbid

Forbidding a patch means adding a filter that will remove the patch from the
repository when creating the testing or production snapshot, thus make it
invisible for the clients.

Patches can be
forbidden in two ways: individually, using their ID (patchname-version), or by
category (security, optional, etc.). The C<allow> and C<forbid> command together
with I<--patch>, I<--category>, I<--all>, and I<--individually> options allows
to do this.

After making chnages with C<allow> or C<forbid>, make sure to use the
C<listupdates> command to re-check which patches are scheduled to appear in or
be removed from the testing snapshot.

Note that a patch can be forbidden in multiple ways (currently the above two)
at the same time. For example, if you have forbidden all optional patches using
C<forbid RepoID --category optional> and then try to allow one of the optional
patches using C<allow RepoID --patch foo-3>, the program will issue a warning
that the foo-3 patch is still forbidden by category 'optional'. You have to do
the following in this case (if that is what you really want):

 $ smt staging allow RepoID --category optional
 $ smt staging forbid RepoID --category optional --individually
 $ smt staging allow RepoID --patch foo-3

=back

=head1 COMMAND-SPECIFIC OPTIONS

=over 4

=item --patch

Specify a patch using its ID, that is 'I<patchname-version>'. To get a list
of available patches, use the B<listupates> command. This option can be
used multiple times.

This option is used in the B<allow>, B<forbid>, and B<listupdates> commands.

If used in B<listupdates>, the command will print detailed information about
the specified patches. 

=item --category

Specify patch (update) category. The following categories are available:
 security
 recommended
 optional

This option is used in the B<allow>, B<forbid>, and B<listupdates> commands.

=item --all

Allow or forbid all patches in the B<allow> or B<forbid> commands.

=item --individually

Allow or forbid multiple patches (e.g. by category) one by one, that is,
as if the I<--patch> option had been used on each of the patches. 

=item --testing

Used in the B<createrepo> command to generate a repository for testing.
The testing repository will be generated from the full unfiltered local mirror
of the remote repository and written into <MirrorTo>/repo/testing directory,
where MirrorTo is the value taken from the smt.conf configuration file.

=item --production

Used in the B<createrepo> command to generate a repository for production use.
This command should be used after testing have been made on the testing
reposity.

The 'production' repository will be generated from the testing repository
and written into <MirrorTo>/repo directory, where MirrorTo is the value taken
from the smt.conf configuration file. If the testing repository does not exist,
the production repository will be generated from the full unfiltered local
mirror of the remote repository.

=item --nohardlink

Avoid creating of hard links instead of copying files when creating
the testing or production repositories using B<createrepo> command.
If not specified, hard links are created instead of copying wherever possible
to save space and time.

=item --nodesc

Do not print patch descriptions and summaries to save some screen space and make
the output more readable.

Can be used with the B<listupdates> command.

=item --sort-by-version

Sort the C<listupdates> table by patch version. The higher the version, the
newer the patch should be.

=item --sort-by-category

Sort the C<listupdates> table by patch category.

=back

=head1 AUTHORS and CONTRIBUTORS

Jan Kupec

=head1 LICENSE

Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
