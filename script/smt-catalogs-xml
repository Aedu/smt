#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;
use SMT::CLI;
use File::Basename;
use SMT::Utils;
use SMT::Parser::RegData;
use SMT::Parser::NU;
use Text::ASCIITable;
use Data::Dumper;

use Locale::gettext ();
use POSIX ();                   # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

if(!SMT::Utils::dropPrivileges())
{
    print STDERR "Unable to drop privileges. Abort!\n";
    exit 1;
}

my $enable;
my $disable;
my $xmldir = "";
my $enableByProduct = "";
my $disableByProduct = "";
my $enableStaging = 0;
my $disableStaging = 0;
my $debug   = 0;
my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1;
my $logfile = "/dev/null";
my $mirrorable;
my $domirror;
my $verbose;
my $help;

use Getopt::Long;
&Getopt::Long::Configure( 'pass_through', 'no_autoabbrev');
&Getopt::Long::GetOptions(
                          'xml-dir|x=s'          => \$xmldir,
                          'enable-mirror|e'      => \$enable,
                          'disable-mirror|d'     => \$disable,
                          'enable-by-prod|p=s'   => \$enableByProduct,
                          'disable-by-prod=s'    => \$disableByProduct,
                          'enable-staging'       => \$enableStaging,
                          'disable-staging'      => \$disableStaging,
                          'debug|d'              => \$debug,
                          "logfile|L=s"          => \$logfile,
                          'only-mirrorable|m'    => \$mirrorable,
                          'only-enabled|o'       => \$domirror,
                          'verbose|v'            => \$verbose,
                          'help|h'               => \$help
                         );


if ( defined $help and ( $help == 1 ) )
{
    print basename($0) . " [name] [target]: " . __("Enable or disable mirroring of a catalog\n");
    print "   --xml-dir         (-x) :     " . __("path to directory containing XML files as created\n");
    print "                                " . __("by smt-ncc-sync --todir\n");
    print "   --enable-mirror   (-e) :     " . __("enable catalog mirorring for \$catalog\n");
    print "   --disable-mirror  (-d) :     " . __("disable catalog mirroring for \$catalog\n");
    print "   --enable-by-prod  (-p) arg : " . __("enable catalog mirroring by giving product data\n");
    print "                                Product[,Version[,Architecture[,Release]]]\n";
    print "                                (call smt list-products to get a list of known products)\n";
    print "   --disable-by-prod  arg :     " . __("disable catalog mirroring by giving product data\n");
    print "                                Product[,Version[,Architecture[,Release]]]\n";
    print "                                (call smt list-products to get a list of known products)\n";
    print "   --enable-staging       :     " . __("Enable staging for a catalog\n");
    print "   --disable-staging      :     " . __("Disable staging for a catalog\n");
    print "   --only-mirrorable (-m) :     " . __("only show mirrorable catalogs\n");
    print "   --only-enabled    (-o) :     " . __("only show catalogs set to be mirrored\n");
    print "   --logfile -L file      :     " . __("Path to logfile\n");
    print "   --debug                :     " . __("Enable debug mode\n");
    print "   --verbose         (-v) :     " . __("show detailed catalog information\n");
    print "   --help            (-v) :     " . __("show this help\n");
    exit 0;
}

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);

if ( $enableByProduct ne "" )
{
    my $ret = SMT::CLI::setCatalogsByProduct( verbose => $verbose, prodStr => $enableByProduct, enable => 1);
    exit $ret;
}
elsif ( $disableByProduct ne "" )
{
    my $ret = SMT::CLI::setCatalogsByProduct( verbose => $verbose, prodStr => $disableByProduct, enable => 0);
    exit $ret;
}

my $name = shift(@ARGV);

if ( defined $disable && defined $enable )
{
    die __("Neurosis is the inability to tolerate ambiguity. Sigmund Freud.\n");
}

if ( $disableStaging && $enableStaging )
{
    die __("Neurosis is the inability to tolerate ambiguity. Sigmund Freud.\n");
}

my $bool;
if ( defined $disable )
{
    $bool = ( $disable == 1 ? 0 : 1 );
}

if ( defined $enable )
{
    $bool = ( $enable == 1 ? 1 : 0 );
}

my $boolStaging;
if ( defined $disableStaging )
{
    $boolStaging = ( $disableStaging == 1 ? 0 : 1 );
}

if ( defined $enableStaging )
{
    $boolStaging = ( $enableStaging == 1 ? 1 : 0 );
}

my $target = shift(@ARGV);

# open the logfile
my $LOG = SMT::Utils::openLog($logfile);

my ($cfg, $dbh, $nuri) = SMT::CLI::init();

my $count = 0;
my @catalogs;


if ($xmldir ne "" && ! -d $xmldir)
{
    print STDERR sprintf(__("Directory '%s' does not exist."), $xmldir);
    exit 1;
}

my $catalogsfile = $xmldir."/catalogs.xml";
my $mirrorinfofile = $xmldir."/mirrorinfo.xml";
my $indexfile = $xmldir."/repo/repoindex.xml";

my $mirrorable_idx = {};
my @mirrorable;
my @mirrorable_test;
my @tomirror = ();
my $mirror_hash = {};
if ( -f "$mirrorinfofile" )
{
    my $cat_parser = SMT::Parser::RegData->new(vblevel => 0, log => undef);
    $cat_parser->parse($mirrorinfofile,
                sub {
                    my $mirrorinfo = shift;
                    push @tomirror, $mirrorinfo;
                    $mirror_hash->{$mirrorinfo->{CATALOGID}} = 1;
                }
    );
}

if ( ! -f "$xmldir/mirrorable.xml" || (stat($catalogsfile))[9] > (stat($xmldir."/mirrorable.xml"))[9]
                                   || (stat($indexfile))[9] > (stat($xmldir."/mirrorable.xml"))[9] )
{
    SMT::Utils::printLog($LOG, $vblevel, LOG_DEBUG, "Regenerating mirrorable file");

    my $idx_hash = {};   
    my $idx_parser = SMT::Parser::NU->new( vblevel => 0, log => undef );
    $idx_parser->parse( $indexfile,
                        sub {
                            my $idxdata = shift;
                            $idx_hash->{$idxdata->{NAME}}->{$idxdata->{DISTRO_TARGET}} = 1;
                        }
                      );

    my $mirrorable_test = ();   
    my $cat_parser = SMT::Parser::RegData->new(vblevel => 0, log => undef);
    $cat_parser->parse($catalogsfile, 
                       sub {
                           my $catalogdata = shift;
                           if ( $catalogdata->{CATALOGTYPE} eq "nu" ||  $catalogdata->{CATALOGTYPE} eq "yum" )
                           {
                               $catalogdata->{LOCALPATH} = '$RCE/'.$catalogdata->{NAME}."/".$catalogdata->{TARGET};

                               if ( defined $idx_hash->{$catalogdata->{NAME}}->{$catalogdata->{TARGET}} &&
                                    $idx_hash->{$catalogdata->{NAME}}->{$catalogdata->{TARGET}} == 1)
                               {
                                   SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, 
                                        sprintf( "Mirrorable Catalog '%s %s'", $catalogdata->{NAME},$catalogdata->{TARGET}) );
                                   $mirrorable_idx->{$catalogdata->{CATALOGID}} = 1;
                               }
                           }
                           if ( $catalogdata->{CATALOGTYPE} eq "zypp" )
                           {
                               SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, 
                                        sprintf("catalog %s needs testing\n", $catalogdata->{NAME}) );
                               # ATI and nvidia workaround as in RegData.pm
                               if($catalogdata->{NAME} eq "ATI-Drivers" && $catalogdata->{EXTURL} =~ /sle10sp1/)
                               {
                                   $catalogdata->{NAME} = $catalogdata->{NAME}."-SP1";
                               }
                               elsif($catalogdata->{NAME} eq "nVidia-Drivers" && $catalogdata->{EXTURL} =~ /sle10sp1/)
                               {
                                   $catalogdata->{NAME} = $catalogdata->{NAME}."-SP1";
                               }
                               $catalogdata->{LOCALPATH} = 'RPMMD/'.$catalogdata->{NAME};
                               push @mirrorable_test, $catalogdata;
                           }
                           push @mirrorable, $catalogdata;
                       }
        );

}
my $useragent = SMT::Utils::createUserAgent(keep_alive => 1);
foreach my $v (@mirrorable_test)
{ 
    my $catName = $v->{NAME};
    my $catUrl = $v->{EXTURL};
    my $catTarget = (defined $v->{TARGET}) ?  $v->{TARGET} : "--";
    if( $catUrl ne "" )
    {
        my $ret = 1;
        # on nu.novell.com we need to authenticate, so put the
        # userinfo into this url
        my $url = URI->new($catUrl);
        if($url->host eq "nu.novell.com")
        {
            my $uuri = URL->new($nuri);
            my $userinfo = $uuri->userinfo;
            $url->userinfo($userinfo);
        }

        my $tempdir = File::Temp::tempdir("smt-XXXXXXXX", CLEANUP => 1, TMPDIR => 1);
        my $remote = $url->as_string()."/repodata/repomd.xml";
        my $local = $tempdir."/repodata/repomd.xml";
        # make sure the container destination exists
        &File::Path::mkpath( dirname($local) );
        
        my $redirects = 0;
        my $response;
        
        do
        {
            eval
            {
                $response = $useragent->get( $remote, ':content_file' => $local );
            };
            if($@)
            {
                SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, $@ );
                $ret = 1;
                last;
            }
            
            if ( $response->is_redirect )
            {
                $redirects++;
                if($redirects > 2)
                {
                    $ret = 1;
                    last
                }
                
                my $newuri = $response->header("location");
                
                SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, "Redirected to $newuri" );
                $remote = URI->new($newuri);
            }
            elsif($response->is_success)
            {
                $ret = 0;
            }
        } while($response->is_redirect);
        if ( $ret == 0 )
        {
            $mirrorable_idx->{$v->{CATALOGID}} = 1;
        }
    }
}


#my $sql = "select * from Catalogs";
#
#$sql = $sql . " where 1";
#
#if ( defined($mirrorable) )
#{
#    if (  $mirrorable == 1 )
#    {
#        $sql = $sql . " and MIRRORABLE='Y'";
#    }
#    else
#    {
#        $sql = $sql . " and MIRRORABLE='N'";
#    }
#}
#
#if ( defined($domirror) )
#{
#    if (  $domirror == 1 )
#    {
#        $sql = $sql . " and DOMIRROR='Y'";
#    }
#    else
#    {
#        $sql = $sql . " and DOMIRROR='N'";
#    }
#}
#
#if (defined $name && $name ne "")
#{
#    $sql = $sql . sprintf(" and NAME=%s", $dbh->quote($name) );
#}
## if target was given, limit the search even more
#if (defined $target && $target ne "")
#{
#    $sql = $sql . sprintf(" and TARGET=%s", $dbh->quote($target) );
#}
#
#$sql = $sql . " order by NAME, TARGET";

# hash to associate order with id.
my @idnumbers;
my $arrayIdx=0;
#my $sth = $dbh->prepare($sql);
#$sth->execute();

my $t = new Text::ASCIITable;
$t->setCols(__("Mirror?"), __("ID"), __("Type"), __("Name"), __("Target"), __("Description"), __("Can be Mirrored"), __("Staging"));

@mirrorable = sort { lc($a->{NAME}) cmp lc($b->{NAME}) || lc($a->{TARGET}) cmp lc($b->{TARGET})} @mirrorable;
foreach my $v ( @mirrorable )
{
    my $catId = $v->{CATALOGID};
    my $catName = $v->{NAME};
    my $catTarget = (defined $v->{TARGET}) ?  $v->{TARGET} : "--";
    my $catType = $v->{CATALOGTYPE};
    my $catDesc = $v->{DESCRIPTION};
    my $catMA   = ( defined $mirrorable_idx->{$catId} && $mirrorable_idx->{$catId} == 1 ) ?
                  __("Yes") : __("No") ;
    my $mirrorEnabled = ( defined $mirror_hash->{$catId} && $mirror_hash->{$catId} == 1 ) ? __("Yes") : __("No");
    my $catStaging = $v->{STAGING} || 'N';
    if ( (! defined $name || $name eq $catName ) &&
         (! defined $target || $target eq $catTarget ) )
    {
        $count++;
        push(@idnumbers, $arrayIdx );
        $t->addRow(  $mirrorEnabled, $count, $catType, $catName, $catTarget, 
                    $catDesc,  $catMA, (( $catStaging eq "Y" ) ? __("Yes") : __("No")));
    }
    $arrayIdx++;
  
    if (defined($verbose))
    {
#        my $st = sprintf("select p.PRODUCTDATAID, p.PRODUCT, p.VERSION, p.ARCH, p.REL, pc.OPTIONAL from Products p, ProductCatalogs pc where pc.CATALOGID=%s and p.PRODUCTDATAID = pc.PRODUCTDATAID order by p.PRODUCT, p.VERSION, p.ARCH, p.REL",
#                         $dbh->quote($catId));
#        my $products = $dbh->selectall_arrayref($st,{Slice=>{}} );
#      
#        print "[" . (( $v->{DOMIRROR} eq "Y" ) ? "*] " : " ] ") . "[" . sprintf("%3d", $count) . "] " . $catName ." " . $catTarget ."\n";
#        print "          (" . $v->{DESCRIPTION} .")\n";
#        print "          " . $v->{EXTURL} ."\n";
#        print "          " . $v->{LOCALPATH} ."\n";
#        print "          CatalogID: " . $v->{CATALOGID} ."\n";
#        print "          Staging  : " . $catStaging ."\n";
#        foreach my $h (@{$products})
#        {
#            my $product = (defined $h->{PRODUCT}?$h->{PRODUCT}:"");
#            my $version = (defined $h->{VERSION}?$h->{VERSION}:"");
#            my $arch    = (defined $h->{ARCH}?$h->{ARCH}:"");
#            my $rel     = (defined $h->{REL}?$h->{REL}:"");
#                           
#            print "          Assigned to product: $product $version $arch $rel\n";
#        }
    }
}

print $t->draw() if not defined($verbose);

if ( ! defined $disable && ! defined $enable &&
     ! $disableStaging && ! $enableStaging)
{
    # not do any action, display was enough
    exit 0;
}

if ( $count == 0 )
{
    die __(sprintf("no catalog named %s\n", $name));
}
elsif ( $count == 1 )
{
    # we are lucky, only one
    if ( $disable || $enable )
    {
        $arrayIdx = $idnumbers[0];
        my $selcat = $mirrorable[$arrayIdx];
        print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
        push @tomirror, $selcat;
    }
    elsif( $disableStaging || $enableStaging)
    {
        my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, id => $idnumbers[0]);
        print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
        exit 0;
    }
}
else
{
    print __(sprintf("Select catalog number (or all) to change,  (1-". $count.",a) :") );

    my $answer = <STDIN>;
    chomp($answer);
  
    if (lc($answer) eq __("a"))
    {
        if ( $disable || $enable )
        {
            foreach my $idx (@idnumbers)
            {
                my $selcat = $mirrorable[$idx];
                print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
                push @tomirror, $selcat;
            }
        }
        elsif( $disableStaging || $enableStaging)
        {   
            my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, name => $name, target => $target);
            print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
            exit 0;
        }
    }
    elsif ( $answer =~ /^[0-9]+$/ && int($answer) <= $count && int($answer) > 0 )
    {
        my $number = int($answer);

        if ( $disable || $enable )
        {
            $arrayIdx = $idnumbers[$number-1];
            my $selcat = $mirrorable[$arrayIdx];
            print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
            push @tomirror, $selcat;
        }
        elsif( $disableStaging || $enableStaging)
        {
            my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, id => $idnumbers[$number-1]);
            print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
            exit 0;
        }
    }
    else
    {
        print __("canceled.\n");
    }
}

SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, Data::Dumper->Dump([\@tomirror]) );
my $output = new IO::File("> $xmldir/mirrorinfo.xml");
if(!defined $output)
{
    die "Cannot open file '$xmldir/mirrorinfo.xml':$!";
}
    
my $writer = new XML::Writer(OUTPUT => $output);

$writer->xmlDecl("UTF-8");
$writer->startTag("catalogs", xmlns => "http://www.novell.com/xml/center/regsvc-1_0");

foreach my $row (@tomirror)
{
    $writer->startTag("row");
    foreach my $col (keys %{$row})
    {
        if ($col eq "CATALOGTYPE" || $col eq "NAME" || $col eq "TARGET" || $col eq "EXTURL" ||
            $col eq "CATALOGID" || $col eq "LOCALPATH" || $col eq "DESCRIPTION" )
        {
            $writer->startTag("col", name => $col);
            $writer->characters($row->{$col});
            $writer->endTag("col");
        }
    }
    $writer->endTag("row");
}
$writer->endTag("catalogs");
$writer->end();
$output->close();

exit 0;

#
# Manpage
#

=head1 NAME

smt catalogs-xml -  

=head1 SYNOPSIS

smt catalogs-xml [options] [name] [target]

=head1 DESCRIPTION

C<smt catalogs-xml> shows information about known catalogs allowing filtering by varous criteria, and allows to activate or deactivate catalogs for mirroring. Oposed to C<smt catalogs> doesn't need to access the database but works on the XML files as created by C<smt ncc-sync --todir>.

=head1 OPTIONS


=head2 COMMANDLINE

=over

=item [name]

Filters by catalog name.

=item [target]

Additionally to catalog name, filter by catalog target.

=item --enable-mirror -e

Enables mirroring of a catalog.

=item --disable-mirror -d

Disables mirroring of a catalog.

=item --enable-by-prod -p arg

Enables catalog mirroring by giving product data.

Product[,Version[,Architecture[,Release]]]
(call smt list-products to get a list of known products)

=item --only-mirrorable -m

Shows mirrorable catalogs only.

=item --only-enabled -o 

Shows catalogs set to be mirrored only.

=item --verbose -v

Shows detailed catalog information.

=head1 AUTHORS and CONTRIBUTORS

Duncan Mac-Vicar Prett, Lukas Ocilka, Jens Daniel Schmidt, Michael Calmer

=head1 LICENSE

Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut


