#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;
use SMT::CLI;
use File::Basename;
use SMT::Utils;
use SMT::Parser::RegData;
use SMT::Parser::NU;
use Text::ASCIITable;
use Data::Dumper;

use Locale::gettext ();
use POSIX ();                   # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

if(!SMT::Utils::dropPrivileges())
{
    print STDERR "Unable to drop privileges. Abort!\n";
    exit 1;
}

my $enable;
my $disable;
my $xmldir = "";
my $enableByProduct = "";
my $disableByProduct = "";
my $enableStaging = 0;
my $disableStaging = 0;
my $debug   = 0;
my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1;
my $logfile = "/dev/null";
my $mirrorable;
my $domirror;
my $verbose;
my $help;

use Getopt::Long;
&Getopt::Long::Configure( 'pass_through', 'no_autoabbrev');
&Getopt::Long::GetOptions(
                          'xml-dir|x=s'          => \$xmldir,
                          'enable-mirror|e'      => \$enable,
                          'disable-mirror|d'     => \$disable,
                          'enable-by-prod|p=s'   => \$enableByProduct,
                          'disable-by-prod=s'    => \$disableByProduct,
                          'enable-staging'       => \$enableStaging,
                          'disable-staging'      => \$disableStaging,
                          'debug'              => \$debug,
                          "logfile|L=s"          => \$logfile,
                          'only-mirrorable|m'    => \$mirrorable,
                          'only-enabled|o'       => \$domirror,
                          'verbose|v'            => \$verbose,
                          'help|h'               => \$help
                         );


if ( defined $help and ( $help == 1 ) )
{
    print basename($0) . " [name] [target]: " . __("Enable or disable mirroring of a catalog\n");
    print "   --xml-dir         (-x) :     " . __("path to directory containing XML files as created\n");
    print "                                " . __("by smt-ncc-sync --todir\n");
    print "   --enable-mirror   (-e) :     " . __("enable catalog mirorring for \$catalog\n");
    print "   --disable-mirror  (-d) :     " . __("disable catalog mirroring for \$catalog\n");
    print "   --enable-by-prod  (-p) arg : " . __("enable catalog mirroring by giving product data\n");
    print "                                Product[,Version[,Architecture[,Release]]]\n";
    print "                                (call smt list-products to get a list of known products)\n";
    print "   --disable-by-prod  arg :     " . __("disable catalog mirroring by giving product data\n");
    print "                                Product[,Version[,Architecture[,Release]]]\n";
    print "                                (call smt list-products to get a list of known products)\n";
    print "   --enable-staging       :     " . __("Enable staging for a catalog\n");
    print "   --disable-staging      :     " . __("Disable staging for a catalog\n");
    print "   --only-mirrorable (-m) :     " . __("only show mirrorable catalogs\n");
    print "   --only-enabled    (-o) :     " . __("only show catalogs set to be mirrored\n");
    print "   --logfile -L file      :     " . __("Path to logfile\n");
    print "   --debug                :     " . __("Enable debug mode\n");
    print "   --verbose         (-v) :     " . __("show detailed catalog information\n");
    print "   --help            (-v) :     " . __("show this help\n");
    exit 0;
}

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);

if ( $enableByProduct ne "" )
{
    my $ret = SMT::CLI::setCatalogsByProduct( verbose => $verbose, prodStr => $enableByProduct, enable => 1);
    exit $ret;
}
elsif ( $disableByProduct ne "" )
{
    my $ret = SMT::CLI::setCatalogsByProduct( verbose => $verbose, prodStr => $disableByProduct, enable => 0);
    exit $ret;
}

my $name = shift(@ARGV);

if ( defined $disable && defined $enable )
{
    die __("Neurosis is the inability to tolerate ambiguity. Sigmund Freud.\n");
}

if ( $disableStaging && $enableStaging )
{
    die __("Neurosis is the inability to tolerate ambiguity. Sigmund Freud.\n");
}

my $bool;
if ( defined $disable )
{
    $bool = ( $disable == 1 ? 0 : 1 );
}

if ( defined $enable )
{
    $bool = ( $enable == 1 ? 1 : 0 );
}

my $boolStaging;
if ( defined $disableStaging )
{
    $boolStaging = ( $disableStaging == 1 ? 0 : 1 );
}

if ( defined $enableStaging )
{
    $boolStaging = ( $enableStaging == 1 ? 1 : 0 );
}

my $target = shift(@ARGV);

# open the logfile
my $LOG = SMT::Utils::openLog($logfile);

my ($cfg, $dbh, $nuri) = SMT::CLI::init();

my $count = 0;
my @catalogs;


if ($xmldir ne "" && ! -d $xmldir)
{
    print STDERR sprintf(__("Directory '%s' does not exist."), $xmldir);
    exit 1;
}

my $catalogsfile = $xmldir."/catalogs.xml";
my $mirrorinfofile = $xmldir."/mirrorinfo.xml";
my $mirrorablefile = $xmldir."/mirrorable.xml";
my $indexfile = $xmldir."/repo/repoindex.xml";

my $mirrorable_idx = {};
my @cataloginfo_int;
my @mirrorable_test;
my @tomirror = ();
my $mirror_hash = {};
if ( -f "$mirrorinfofile" )
{
    my $cat_parser = SMT::Parser::RegData->new(vblevel => 0, log => undef);
    $cat_parser->parse($mirrorinfofile,
                sub {
                    my $mirrorinfo = shift;
                    push @tomirror, $mirrorinfo;
                    $mirror_hash->{$mirrorinfo->{CATALOGID}} = 1;
                }
    );
}

my $idx_hash = {};   
my $mirrorable_update_needed=0;
if ( ! -f "$mirrorablefile" || (stat($catalogsfile))[9] > (stat($mirrorablefile))[9]
                            || (stat($indexfile))[9] > (stat($mirrorablefile))[9] )
{
    SMT::Utils::printLog($LOG, $vblevel, LOG_DEBUG, "Mirrorable file needs update");
    $mirrorable_update_needed =1;
    my $idx_parser = SMT::Parser::NU->new( vblevel => 0, log => undef );
    $idx_parser->parse( $indexfile,
        sub {
            my $idxdata = shift;
            $idx_hash->{$idxdata->{NAME}}->{$idxdata->{DISTRO_TARGET}} = 1;
        }
    );
}
else
{
    my $mirrorable_parser = SMT::Parser::RegData->new(vblevel => 0, log => undef);
    $mirrorable_parser->parse($mirrorablefile, 
        sub {
            my $data = shift;
            $mirrorable_idx->{$data->{CATALOGID}} = 1;
        }
    );
}

my $mirrorable_test = ();   
my $cat_parser = SMT::Parser::RegData->new(vblevel => 0, log => undef);
$cat_parser->parse($catalogsfile, 
    sub {
       my $catalogdata = shift;
       if ( $catalogdata->{CATALOGTYPE} eq "nu" ||  $catalogdata->{CATALOGTYPE} eq "yum" )
       {
           $catalogdata->{LOCALPATH} = '$RCE/'.$catalogdata->{NAME}."/".$catalogdata->{TARGET};

           if ($mirrorable_update_needed == 1 &&
               defined $idx_hash->{$catalogdata->{NAME}}->{$catalogdata->{TARGET}} &&
               $idx_hash->{$catalogdata->{NAME}}->{$catalogdata->{TARGET}} == 1)
           {
               SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, 
                    sprintf( "Mirrorable Catalog '%s %s'", $catalogdata->{NAME},$catalogdata->{TARGET}) );
               $mirrorable_idx->{$catalogdata->{CATALOGID}} = 1;
           }
       }
       if ( $catalogdata->{CATALOGTYPE} eq "zypp" )
       {
           # ATI and nvidia workaround as in RegData.pm
           if($catalogdata->{NAME} eq "ATI-Drivers" && $catalogdata->{EXTURL} =~ /sle10sp1/)
           {
               $catalogdata->{NAME} = $catalogdata->{NAME}."-SP1";
           }
           elsif($catalogdata->{NAME} eq "nVidia-Drivers" && $catalogdata->{EXTURL} =~ /sle10sp1/)
           {
               $catalogdata->{NAME} = $catalogdata->{NAME}."-SP1";
           }
           $catalogdata->{LOCALPATH} = 'RPMMD/'.$catalogdata->{NAME};
           if ($mirrorable_update_needed == 1 )
           {
               SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, 
                    sprintf("catalog %s needs testing", $catalogdata->{NAME}) );
               push @mirrorable_test, $catalogdata;
           }
       }
       push @cataloginfo_int, $catalogdata;
    }
);

my $useragent = SMT::Utils::createUserAgent(keep_alive => 1);
if ( $mirrorable_update_needed == 1 )
{
    foreach my $v (@mirrorable_test)
    { 
        my $catName = $v->{NAME};
        my $catUrl = $v->{EXTURL};
        my $catTarget = (defined $v->{TARGET}) ?  $v->{TARGET} : "--";
        if( $catUrl ne "" )
        {
            my $ret = SMT::CLI::isZyppMirrorable( log        => $LOG,
                                                  vblevel    => $vblevel,
                                                  NUUri      => $nuri,
                                                  catalogurl => $catUrl,
                                                  useragent  => $useragent );
            if ( $ret == 1 )
            {
                $mirrorable_idx->{$v->{CATALOGID}} = 1;
            }
        }
    }

    # writing updated mirrorable file
    my $output = new IO::File("> $mirrorablefile");
    if(!defined $output)
    {
        die "Cannot open file '$mirrorablefile':$!";
    }
        
    my $writer = new XML::Writer(OUTPUT => $output);

    $writer->xmlDecl("UTF-8");
    $writer->startTag("catalogs", xmlns => "http://www.novell.com/xml/center/regsvc-1_0");

    foreach my $catalogid ( keys %{$mirrorable_idx})
    {
        $writer->startTag("row");
        $writer->startTag("col", name => "CATALOGID");
        $writer->characters($catalogid);
        $writer->endTag("col");
        $writer->endTag("row");
    }
    $writer->endTag("catalogs");
    $writer->end();
    $output->close();
}

# hash to associate order with id.
my @idnumbers;
my $arrayIdx=0;
#my $sth = $dbh->prepare($sql);
#$sth->execute();

my $t = new Text::ASCIITable;
$t->setCols(__("Mirror?"), __("ID"), __("Type"), __("Name"), __("Target"), __("Description"), __("Can be Mirrored"), __("Staging"));

@cataloginfo_int = sort { lc($a->{NAME}) cmp lc($b->{NAME}) || lc($a->{TARGET}) cmp lc($b->{TARGET})} @cataloginfo_int;
foreach my $v ( @cataloginfo_int )
{
    my $catId = $v->{CATALOGID};
    my $catName = $v->{NAME};
    my $catTarget = (defined $v->{TARGET}) ?  $v->{TARGET} : "--";
    my $catType = $v->{CATALOGTYPE};
    my $catDesc = $v->{DESCRIPTION};
    my $catMA   = ( defined $mirrorable_idx->{$catId} && $mirrorable_idx->{$catId} == 1 ) ?
                  __("Yes") : __("No") ;
    my $mirrorEnabled = ( defined $mirror_hash->{$catId} && $mirror_hash->{$catId} == 1 ) ? __("Yes") : __("No");
    my $catStaging = $v->{STAGING} || 'N';
    if ( (! defined $name || $name eq $catName ) &&
         (! defined $target || $target eq $catTarget ) )
    {
        $count++;
        push(@idnumbers, $arrayIdx );
        $t->addRow(  $mirrorEnabled, $count, $catType, $catName, $catTarget, 
                    $catDesc,  $catMA, (( $catStaging eq "Y" ) ? __("Yes") : __("No")));
    }
    $arrayIdx++;
  
    if (defined($verbose))
    {
#        my $st = sprintf("select p.PRODUCTDATAID, p.PRODUCT, p.VERSION, p.ARCH, p.REL, pc.OPTIONAL from Products p, ProductCatalogs pc where pc.CATALOGID=%s and p.PRODUCTDATAID = pc.PRODUCTDATAID order by p.PRODUCT, p.VERSION, p.ARCH, p.REL",
#                         $dbh->quote($catId));
#        my $products = $dbh->selectall_arrayref($st,{Slice=>{}} );
#      
#        print "[" . (( $v->{DOMIRROR} eq "Y" ) ? "*] " : " ] ") . "[" . sprintf("%3d", $count) . "] " . $catName ." " . $catTarget ."\n";
#        print "          (" . $v->{DESCRIPTION} .")\n";
#        print "          " . $v->{EXTURL} ."\n";
#        print "          " . $v->{LOCALPATH} ."\n";
#        print "          CatalogID: " . $v->{CATALOGID} ."\n";
#        print "          Staging  : " . $catStaging ."\n";
#        foreach my $h (@{$products})
#        {
#            my $product = (defined $h->{PRODUCT}?$h->{PRODUCT}:"");
#            my $version = (defined $h->{VERSION}?$h->{VERSION}:"");
#            my $arch    = (defined $h->{ARCH}?$h->{ARCH}:"");
#            my $rel     = (defined $h->{REL}?$h->{REL}:"");
#                           
#            print "          Assigned to product: $product $version $arch $rel\n";
#        }
    }
}

print $t->draw() if not defined($verbose);

if ( ! defined $disable && ! defined $enable &&
     ! $disableStaging && ! $enableStaging)
{
    # not do any action, display was enough
    exit 0;
}

if ( $count == 0 )
{
    die __(sprintf("no catalog named %s\n", $name));
}
elsif ( $count == 1 )
{
    # we are lucky, only one
    if ( $disable || $enable )
    {
        $arrayIdx = $idnumbers[0];
        my $selcat = $cataloginfo_int[$arrayIdx];
        print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
        if ( $bool )
        {
            push @tomirror, $selcat;
        }
        else
        {
            my $i = 0;
            for my $element (@tomirror)
            {
                if ( $selcat->{CATALOGID} eq $element->{CATALOGID} )
                {
                    splice @tomirror, $i, 1;
                    last;
                }
                $i++
            }
        }
    }
    elsif( $disableStaging || $enableStaging)
    {
        my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, id => $idnumbers[0]);
        print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
        exit 0;
    }
}
else
{
    print __(sprintf("Select catalog number (or all) to change,  (1-". $count.",a) :") );

    my $answer = <STDIN>;
    chomp($answer);
  
    if (lc($answer) eq __("a"))
    {
        if ( $disable || $enable )
        {
            foreach my $idx (@idnumbers)
            {
                my $selcat = $cataloginfo_int[$idx];
                print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
                if ( $bool )
                {
                    push @tomirror, $selcat;
                }
                else
                {
                    my $i = 0;
                    for my $element (@tomirror)
                    {
                        if ( $selcat->{CATALOGID} eq $element->{CATALOGID} )
                        {
                            splice @tomirror, $i, 1;
                            last;
                        }
                        $i++
                    }
                }
            }
        }
        elsif( $disableStaging || $enableStaging)
        {   
            my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, name => $name, target => $target);
            print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
            exit 0;
        }
    }
    elsif ( $answer =~ /^[0-9]+$/ && int($answer) <= $count && int($answer) > 0 )
    {
        my $number = int($answer);

        if ( $disable || $enable )
        {
            $arrayIdx = $idnumbers[$number-1];
            my $selcat = $cataloginfo_int[$arrayIdx];
            print sprintf(__("%s %s Catalog(s) %s.\n"), $selcat->{NAME}, $selcat->{TARGET}, ($bool?__("enabled"):__("disabled")) );
            if ( $bool )
            {
                push @tomirror, $selcat;
            }
            else
            {
                my $i = 0;
                for my $element (@tomirror)
                {
                    if ( $selcat->{CATALOGID} eq $element->{CATALOGID} )
                    {
                        splice @tomirror, $i, 1;
                        last;
                    }
                    $i++
                }
            }
        }
        elsif( $disableStaging || $enableStaging)
        {
            my $rows = SMT::CLI::setCatalogStaging(enabled => $boolStaging, id => $idnumbers[$number-1]);
            print sprintf(__("%d Catalog(s) %s.\n"), $rows, ($boolStaging?__("staging enabled"):__("staging disabled")) );
            exit 0;
        }
    }
    else
    {
        print __("canceled.\n");
    }
}

SMT::Utils::printLog( $LOG, $vblevel, LOG_DEBUG, Data::Dumper->Dump([\@tomirror]) );
my $output = new IO::File("> $xmldir/mirrorinfo.xml");
if(!defined $output)
{
    die "Cannot open file '$xmldir/mirrorinfo.xml':$!";
}
    
my $writer = new XML::Writer(OUTPUT => $output);

$writer->xmlDecl("UTF-8");
$writer->startTag("catalogs", xmlns => "http://www.novell.com/xml/center/regsvc-1_0");

foreach my $row (@tomirror)
{
    $writer->startTag("row");
    foreach my $col (keys %{$row})
    {
        if ($col eq "CATALOGTYPE" || $col eq "NAME" || $col eq "TARGET" || $col eq "EXTURL" ||
            $col eq "CATALOGID" || $col eq "LOCALPATH" || $col eq "DESCRIPTION" )
        {
            $writer->startTag("col", name => $col);
            $writer->characters($row->{$col});
            $writer->endTag("col");
        }
    }
    $writer->endTag("row");
}
$writer->endTag("catalogs");
$writer->end();
$output->close();

exit 0;

#
# Manpage
#

=head1 NAME

smt catalogs-xml -  

=head1 SYNOPSIS

smt catalogs-xml [options] [name] [target]

=head1 DESCRIPTION

C<smt catalogs-xml> shows information about known catalogs allowing filtering by varous criteria, and allows to activate or deactivate catalogs for mirroring. Oposed to C<smt catalogs> doesn't need to access the database but works on the XML files as created by C<smt ncc-sync --todir>.

=head1 OPTIONS


=head2 COMMANDLINE

=over

=item [name]

Filters by catalog name.

=item [target]

Additionally to catalog name, filter by catalog target.

=item --enable-mirror -e

Enables mirroring of a catalog.

=item --disable-mirror -d

Disables mirroring of a catalog.

=item --enable-by-prod -p arg

Enables catalog mirroring by giving product data.

Product[,Version[,Architecture[,Release]]]
(call smt list-products to get a list of known products)

=item --only-mirrorable -m

Shows mirrorable catalogs only.

=item --only-enabled -o 

Shows catalogs set to be mirrored only.

=item --verbose -v

Shows detailed catalog information.

=head1 AUTHORS and CONTRIBUTORS

Duncan Mac-Vicar Prett, Lukas Ocilka, Jens Daniel Schmidt, Michael Calmer

=head1 LICENSE

Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut


