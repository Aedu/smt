#!/usr/bin/perl

use strict;
use warnings;
use lib ("/srv/www/perl-lib/");
use SMT::CLI;
use SMT::Utils;
use File::Basename;

use Locale::gettext ();
use POSIX ();     # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

my $debug;
my $help;
my $mail;    # activate sending of report mail
my $attach;  # attach csv report to report mail
my $quiet;   # suppress output to STDOUT
my $csv;     # export data as csv
my $file;    # write output to file
my $logfile;

use Getopt::Long;

# open the logfile
my $LOG = SMT::Utils::openLog($logfile);


# configuration
my %conf = (
            SUSE         => { 
                             NAME => "openSUSE",
                             ARCHGROUPS => {}
                            },
            SLES         => {
                             NAME => "SUSE Linux Enterprise Server",
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            },
            SLED         => {
                             NAME => "SUSE Linux Enterprise Desktop",
                             ARCHGROUPS => {}
                            },
            ZlmSatellite => {
                             NAME => "Zenworks Linux Management",
                             ARCHGROUPS => {}
                            },
            SDK          => {
                             NAME => "SUSE Linux Enterprise Software Development Kit",
                             ARCHGROUPS => {}
                            },
            SLERT        => {
                             NAME => "SUSE Linux Enterprise Server RT Solution",
                             ARCHGROUPS => {}
                            },
            OES          => {
                             NAME => "Novell Open Enterprise Server",
                             ARCHGROUPS => {}
                            },
            VMDP         => {
                             NAME => "SUSE Linux Enterprise Virtual Machine Driver Pack",
                             ARCHGROUPS => {}
                            },
            Pulsar       => {
                             NAME => "ZENworks Pulsar",
                             ARCHGROUPS => {}
                            },
            "SLES-HA"    => {
                             NAME => "SUSE Linux Enterprise HA Server",
                             ARCHGROUPS => {}
                            },
            ZOS          => {
                             NAME => "ZENworks Orchestrator",
                             ARCHGROUPS => {}
                            },
            SLEDC        => {
                             NAME => "SUSE Linux Enterprise Data Center",
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            },
            SMT_DEFAULT  => {
                             NAME => undef,
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            }
           );



# main hashes that keep the report data
my %REP = ();
my %DATA = (
            'class'   => SMT::CLI::productClassReport(conf => \%conf, log => $LOG, debug => $debug),
            'prodsub' => SMT::CLI::productSubscriptionReport(log => $LOG, debug => $debug),
            'sub'     => SMT::CLI::subscriptionReport(log => $LOG, debug => $debug)
          );


### SUBS #####################################################################

sub printUsage
{
    print basename($0) . " : " . __("generate a report\n");
    print "  --help    (-h) : " . __("print this help\n");
    print "  --debug   (-d) : " . __("enable debug mode\n");
    print "  --mail    (-m) : " . __("enable mailing of report\n");
    print "  --attach (-a) : " . __("attach CSV report files to mail (only together with --mail)\n");
    print "  --quiet   (-q) : " . __("suppress output\n");
    print "  --csv     (-c) : " . __("export data in CSV format\n");
    print "  --file    (-F) [<file>] : " . __("write report to <file>, in csv mode <file> expands to <file-name>-reportname[.<file-extension>]\n");
    print "  --logfile (-L) <file>   : " . __("Path to logfile\n");
}


#
# performs certificate checks and collects the errors found in a list
#      an error is a hash with the type name as key and the message as value
#      returns the error messages as text block
#
sub certificateCheck($$)
{
    my $printIt = shift;
    my $logIt = shift;
    if (!defined $printIt || !defined $logIt) { return ''; }
    my $messageBlock = '';

    my @msg = ();
    my $days = SMT::CLI::certificateExpireCheck(log => $LOG, debug => $debug);
    if(defined $days && $days > 0 && $days <= 10)
    {
        push @msg, { 'warn' => sprintf(__("WARNING: SMT server certificate expired in %s days. Please re-new it soon!"), $days ) };
    }
    elsif(defined $days && $days <= 0)
    {
        push @msg, { 'error' =>  __("ERROR: SMT server certificate is expired!") };
    }

    foreach my $message (@msg)
    {
        while (my ($type, $message) = each(%{$message}) )
        {
            printLog($LOG, $type, $message, $printIt, $logIt);
            $messageBlock .= $message."\n";
        }
    }

    return $messageBlock;
}


#
# will return rendered report and only (re)render if necessary
#   parameters: renderMode, reportName, [subReportName]
#
sub getReportRenderedAs
{
    my $mode   = shift;
    my $report = shift;
    my $subrep = shift;

    if ( ! defined $mode || ! defined $report ) { return ''; }
    if ( ! exists $DATA{$report} ) { return ''; }

    if (defined $subrep && $subrep ne '')
    {
        if ($subrep eq 'summary')
        {
            # do not render summaries
            return $DATA{$report}{$subrep};
        }

        # check if we need to (re)render
        if ( ! exists  $REP{$mode}{$report}{$subrep}  || 
             ! defined $REP{$mode}{$report}{$subrep}    )
        {
            $REP{$mode}{$report}{$subrep} = SMT::CLI::renderReport($DATA{$report}{$subrep}, $mode);
        }
        return $REP{$mode}{$report}{$subrep};
    }
    else
    {
        if ( ! exists  $REP{$mode}{$report}  || 
             ! defined $REP{$mode}{$report}    )
        {
            $REP{$mode}{$report} = SMT::CLI::renderReport($DATA{$report}, $mode);
        }
        return $REP{$mode}{$report};
    }
    # to be safe
    return '';
}


#
# assemble a merged report
#
sub getMergedReport($)
{
    my $renderMode = shift;
    if (! defined $renderMode) { return ''; }
    my %headings = (  'class'   =>  __("Product Class Report"),
                      'sub'     =>  __("Subscription Report based on a local calculation"),
                      'prodsub' =>  __("Subscription Report based on NCC registrations")
                   );

    my $res = '';
    $res .= $headings{'class'}."\n";
    $res .= sprintf '=' x length($headings{'class'})."\n\n";
    $res .= getReportRenderedAs($renderMode, 'class');
    $res .= "\n\n";

    $res .= $headings{'prodsub'}."\n";
    $res .= sprintf '=' x length($headings{'prodsub'})."\n\n";
    $res .= getReportRenderedAs($renderMode, 'prodsub', 'active')."\n";
    $res .= getReportRenderedAs($renderMode, 'prodsub', 'soon')."\n";
    $res .= getReportRenderedAs($renderMode, 'prodsub', 'expired')."\n";
    $res .= getReportRenderedAs($renderMode, 'prodsub', 'summary')."\n";
    $res .= "\n\n"; 

    $res .= $headings{'sub'}."\n";
    $res .= sprintf '=' x length($headings{'sub'})."\n\n";
    $res .= getReportRenderedAs($renderMode, 'sub', 'active')."\n";
    $res .= getReportRenderedAs($renderMode, 'sub', 'soon')."\n";
    $res .= getReportRenderedAs($renderMode, 'sub', 'expired')."\n";
    $res .= getReportRenderedAs($renderMode, 'sub', 'summary')."\n";
    $res .= "\n\n";

    return $res;
}


#
# return s hash with all reports rendered separately
#
sub getSeparateReports($)
{
    my $renderMode = shift;
    my %res = ();
    if (! defined $renderMode) { return %res; }

    $res{'product_class'} = getReportRenderedAs($renderMode, 'class');

    $res{'product_subscription_active'}     = getReportRenderedAs($renderMode, 'prodsub', 'active');
    $res{'product_subscription_expiresoon'} = getReportRenderedAs($renderMode, 'prodsub', 'soon');
    $res{'product_subscription_expired'}    = getReportRenderedAs($renderMode, 'prodsub', 'expired');
    $res{'product_subscription_summary'}    = getReportRenderedAs($renderMode, 'prodsub', 'summary');
   
    $res{'subscription_active'}     = getReportRenderedAs($renderMode, 'sub', 'active');
    $res{'subscription_expiresoon'} = getReportRenderedAs($renderMode, 'sub', 'soon');
    $res{'subscription_expired'}    = getReportRenderedAs($renderMode, 'sub', 'expired');
    $res{'subscription_summary'}    = getReportRenderedAs($renderMode, 'sub', 'summary');

    return %res;
}



### MAIN #####################################################################

&Getopt::Long::Configure( 'pass_through', 'no_autoabbrev');
&Getopt::Long::GetOptions(
         'debug|d'    => \$debug,
         'help|h'     => \$help,
         'mail|m'     => \$mail,
         'attach|a'   => \$attach,
         'quiet|q'    => \$quiet,
         'csv|c'      => \$csv,
         'file|F:s'   => \$file,      # file name is optional; if missing, it will use a default name 
         'logfile|L=s'=> \$logfile
);



if ( defined $help && ( $help == 1 ) )
{
    printUsage();  
    exit 0;
}


# default settings
my $doPrint = 1;
my $doLog = 1; 
my $certErrors = '';
my $datestring = POSIX::strftime("%Y-%m-%d_%H-%M-%S", localtime);
my $defaultFilePrefix = "SMT_report-$datestring";


# set doPrint to 0 if quiet mode selected
if (defined $quiet && $quiet == 1)
{
    $doPrint = 0;
}

# print and log the ascii report if wanted
printLog($LOG, "info", getMergedReport('asciitable'), $doPrint, $doLog);

# print, log and get the certificate check results
$certErrors = certificateCheck($doPrint, $doLog);


if (defined $file)
{
    # exporting the report
    my $fname = '';
    my ($Efile, $Edir, $Eext) = fileparse($file, qr/\.[^.]*/);

    if ($Efile eq '')
    {
        $Efile = $defaultFilePrefix; 
        $Eext  = '';  # trigger automatic extension
    }

    # if file extension is csv we switch to csv export
    if ( (defined $csv && $csv == 1) ||  $Eext eq '.csv' )
    {
        $csv = 1;
    }

    if ($csv)
    {
        if ($Eext eq '') { $Eext = '.csv'; }

        my %rep = getSeparateReports('csv');

        while ( my ($rname, $rdata) = each(%rep) )
        {
            my $extension = $Eext;
            if ($extension eq '.csv'  &&  $rname =~ /summary/i ) { $extension = '.txt';  }
            $fname = $Edir.$Efile.'-'.$rname.$extension;
            open(REPFILE, "> $fname ")  ||  die sprintf(__("Can not open target file %s"), $fname);
            print REPFILE $rdata;
            close REPFILE;
        }
    }
    else
    {
        $fname = $fname = $Edir.$Efile.$Eext;
        open(REPFILE, "> $fname")  ||  die sprintf(__("Can not open target file %s"), $fname);
        print REPFILE getMergedReport('asciitable');
        close REPFILE;
    }

    if ($certErrors ne '')
    {
        $fname = $Edir.$Efile.'-certificatecheck.txt';
        open(ERRFILE, "> $fname");
        print ERRFILE $certErrors;
        close ERRFILE;
    }
}



if (defined $mail  &&  $mail == 1)
{
    my %ATTACH = ();

    if (defined $attach  &&  $attach == 1)
    {
        my %rep = getSeparateReports('csv');

        while ( my ($rname, $rdata) = each(%rep) )
        {
            my $extension = '.csv';
            if ( $rname =~ /summary/i ) { $extension = '.txt';  }
            my $csvName = $defaultFilePrefix.'-'.$rname.$extension;
            $ATTACH{$csvName} = $rdata;
        }

        if (defined $certErrors  &&  $certErrors ne '')
        {
            $ATTACH{"$defaultFilePrefix-certificatecheck .txt"} = $certErrors; 
        }
    }

    my $MailBody = '';
    if ($certErrors ne '') { $MailBody .= $certErrors."\n\n"; }
    $MailBody .= getMergedReport('asciitable');

    SMT::Utils::sendMailToAdmins($MailBody, \%ATTACH);
}


exit 0;
