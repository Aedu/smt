#!/usr/bin/perl

use strict;
use warnings;
use lib ("/srv/www/perl-lib/");
use SMT::CLI;
use SMT::Utils;
use SMT::NCCRegTools;
use File::Basename;

use Locale::gettext ();
use POSIX ();     # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

my $debug;
my $help;
my $mail;    # activate sending of report mail
my $attach;  # attach csv report to report mail
my $quiet;   # suppress output to STDOUT
my $csv;     # export data as csv
my $file;    # write output to file
my $logfile;
my $nonccsync = 0;

# which reports
my $classreport = 0;
my $localreport = 0;
my $nccreport   = 0;


use Getopt::Long;

my $LOG = undef;

# configuration
my %conf = (
            SUSE         => { 
                             NAME => "openSUSE",
                             ARCHGROUPS => {}
                            },
            SLES         => {
                             NAME => "SUSE Linux Enterprise Server",
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            },
            SLED         => {
                             NAME => "SUSE Linux Enterprise Desktop",
                             ARCHGROUPS => {}
                            },
            ZlmSatellite => {
                             NAME => "Zenworks Linux Management",
                             ARCHGROUPS => {}
                            },
            SDK          => {
                             NAME => "SUSE Linux Enterprise Software Development Kit",
                             ARCHGROUPS => {}
                            },
            SLERT        => {
                             NAME => "SUSE Linux Enterprise Server RT Solution",
                             ARCHGROUPS => {}
                            },
            OES          => {
                             NAME => "Novell Open Enterprise Server",
                             ARCHGROUPS => {}
                            },
            VMDP         => {
                             NAME => "SUSE Linux Enterprise Virtual Machine Driver Pack",
                             ARCHGROUPS => {}
                            },
            Pulsar       => {
                             NAME => "ZENworks Pulsar",
                             ARCHGROUPS => {}
                            },
            "SLES-HA"    => {
                             NAME => "SUSE Linux Enterprise HA Server",
                             ARCHGROUPS => {}
                            },
            ZOS          => {
                             NAME => "ZENworks Orchestrator",
                             ARCHGROUPS => {}
                            },
            SLEDC        => {
                             NAME => "SUSE Linux Enterprise Data Center",
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            },
            SMT_DEFAULT  => {
                             NAME => undef,
                             ARCHGROUPS => {
                                            "x86/x86_64" => ['i386', 'i486', 'i586', 'i686', 'x86_64'],
                                            "ppc"        => ['ppc', 'ppc64'],
                                            "s390"       => ['s390', 's390x'],
                                            "ia64"       => ['ia64'],
                                            "unknown"    => [undef]
                                           }
                            }
           );

my $legendLocal = "
Legend:

Subscription:                The name of the subscription.
Locally Registered Machines: The number of clients which are registered against this subscription.
Active Subscriptions:        The number of allowed clients for this subscriptions.
Soon expiring Subscriptions: Like 'Active Subscriptions', but these are expiring soon.
Missing Subscriptions:       The number of clients which require a subscription of this type
                             but no free subscription is available.

Total Subscriptions:         Number of Subscriptions of this type
Used Locally:                Number of clients which are assigned to this type
Expiring Date:               The date when this subscription expires.
";

my $legendNCC   = "
Legend:

Subscription:                The name of the subscription.
Registered Machines at NCC:  The number of clients which are assigned to this subscription.
                             This is a total number over the company, not only this SMT server.
Active Subscriptions:        The number of allowed clients for this subscriptions.
Soon expiring Subscriptions: Like 'Active Subscriptions', but these are expiring soon.
Missing Subscriptions:       The number of clients which require a subscription of this type
                             but no free subscription is available.

Registration Code:           The registration code for this subscription.
Total Subscriptions:         Number of Subscriptions of this type
Total Used:                  Number of used subscriptions (company wide)
Used Locally:                Number of used subscriptions from this SMT server.
Expiring Date:               The date when this subscription expires.
";

my $hostname = `/bin/hostname -f 2>/dev/null`;
$hostname = "unknown" if(!defined $hostname || $hostname eq "");
chomp($hostname);
my $footer      = "
Footer
(Generated on '$hostname')
";



# main hashes that keep the report data
my %REP = ();
my %DATA = ();

### SUBS #####################################################################

sub printUsage
{
    print basename($0) . " : " . __("generate a report")."\n";
    print "  --local        : " . __("force to create a report based on a local calculation")."\n";
    print "  --ncc          : " . __("force to create a report based on NCC data")."\n";
    print "  --nonccsync    : " . __("do not sync with NCC before creating the report")."\n";
    print "  --mail    (-m) : " . __("enable mailing of report")."\n";
    print "  --attach  (-a) : " . __("attach CSV report files to mail (only together with --mail)")."\n";
    print "  --quiet   (-q) : " . __("suppress output")."\n";
    print "  --csv     (-c) : " . __("export data in CSV format")."\n";
    print "  --file    (-F) [<file>] : " . __("write report to a file")."\n";
    print "            " . __("in csv mode <file> expands to [<dir>/]<file-name>-reportname[.<file-extension>]\n");
    print "  --logfile (-L) <file>   : " . __("Path to logfile")."\n";
    print "  --help    (-h) : " . __("print this help")."\n";
    print "  --debug   (-d) : " . __("enable debug mode")."\n";
}


#
# performs certificate checks and collects the errors found in a list
#      an error is a hash with the type name as key and the message as value
#      returns the error messages as text block
#
sub certificateCheck($$)
{
    my $printIt = shift;
    my $logIt = shift;
    if (!defined $printIt || !defined $logIt) { return ''; }
    my $messageBlock = '';

    my @msg = ();
    my $days = SMT::CLI::certificateExpireCheck(log => $LOG, debug => $debug);
    if(defined $days && $days > 0 && $days <= 10)
    {
        push @msg, { 'warn' => sprintf(__("WARNING: SMT server certificate expired in %s days. Please re-new it soon!"), $days ) };
    }
    elsif(defined $days && $days <= 0)
    {
        push @msg, { 'error' =>  __("ERROR: SMT server certificate is expired!") };
    }

    foreach my $message (@msg)
    {
        while (my ($type, $message) = each(%{$message}) )
        {
            printLog($LOG, $type, $message, $printIt, $logIt);
            $messageBlock .= $message."\n";
        }
    }

    return $messageBlock;
}


#
# will return rendered report and only (re)render if necessary
#   parameters: renderMode, reportName, [subReportName]
#
sub getReportRenderedAs
{
    my $mode   = shift;
    my $report = shift;
    my $subrep = shift;

    if ( ! defined $mode || ! defined $report ) { return ''; }
    if ( ! exists $DATA{$report} ) { return ''; }

    if (defined $subrep && $subrep ne '')
    {
        if (($subrep eq 'summary' && ref($DATA{$report}{$subrep}) ne "HASH") ||
            ($subrep eq 'alerts' && ref($DATA{$report}{$subrep}) ne "HASH"))
        {
            # do not render summaries
            return $DATA{$report}{$subrep};
        }

        # check if we need to (re)render
        if ( ! exists  $REP{$mode}{$report}{$subrep}  || 
             ! defined $REP{$mode}{$report}{$subrep}    )
        {
            $REP{$mode}{$report}{$subrep} = SMT::CLI::renderReport($DATA{$report}{$subrep}, $mode);
        }
        return $REP{$mode}{$report}{$subrep};
    }
    else
    {
        if ( ! exists  $REP{$mode}{$report}  || 
             ! defined $REP{$mode}{$report}    )
        {
            $REP{$mode}{$report} = SMT::CLI::renderReport($DATA{$report}, $mode);
        }
        return $REP{$mode}{$report};
    }
    # to be safe
    return '';
}


#
# assemble a merged report
#
sub getMergedReport($)
{
    my $renderMode = shift;
    if (! defined $renderMode) { return ''; }
    my %headings = (
                    'class'   =>  __("Product Class Report"),
                    'sub'     =>  __("Subscription Report based on NCC registrations"),
                    'prodsub' =>  __("Subscription Report based on a local calculation")
                   );

    my $res = '';
    if($classreport)
    {
        $res .= $headings{'class'}."\n";
        $res .= sprintf '=' x length($headings{'class'})."\n\n";
        $res .= getReportRenderedAs($renderMode, 'class');
        $res .= "\n\n";
    }
    
    if($localreport)
    {
        $res .= $headings{'prodsub'}."\n";
        $res .= sprintf '=' x length($headings{'prodsub'})."\n\n";
        $res .= getReportRenderedAs($renderMode, 'prodsub', 'alerts')."\n";
        $res .= getReportRenderedAs($renderMode, 'prodsub', 'summary')."\n";
        $res .= getReportRenderedAs($renderMode, 'prodsub', 'active')."\n";
        $res .= getReportRenderedAs($renderMode, 'prodsub', 'soon')."\n";
        $res .= getReportRenderedAs($renderMode, 'prodsub', 'expired')."\n";
        $res .= "\n\n"; 

        $res .= $legendLocal."\n\n";
    }
    
    if($nccreport)
    {
        $res .= $headings{'sub'}."\n";
        $res .= sprintf '=' x length($headings{'sub'})."\n\n";
        $res .= getReportRenderedAs($renderMode, 'sub', 'alerts')."\n";
        $res .= getReportRenderedAs($renderMode, 'sub', 'summary')."\n";
        $res .= getReportRenderedAs($renderMode, 'sub', 'active')."\n";
        $res .= getReportRenderedAs($renderMode, 'sub', 'soon')."\n";
        $res .= getReportRenderedAs($renderMode, 'sub', 'expired')."\n";
        $res .= "\n\n";

        $res .= $legendNCC."\n\n";
    }
    
    $res .= $footer."\n\n";

    return $res;
}


#
# return s hash with all reports rendered separately
#
sub getSeparateReports($)
{
    my $renderMode = shift;
    my %res = ();
    if (! defined $renderMode) { return %res; }

    $res{'product_class'} = getReportRenderedAs($renderMode, 'class') if($classreport);

    if($localreport)
    {
        $res{'product_subscription_active'}     = getReportRenderedAs($renderMode, 'prodsub', 'active');
        $res{'product_subscription_expiresoon'} = getReportRenderedAs($renderMode, 'prodsub', 'soon');
        $res{'product_subscription_expired'}    = getReportRenderedAs($renderMode, 'prodsub', 'expired');
        $res{'product_subscription_summary'}    = getReportRenderedAs($renderMode, 'prodsub', 'summary');
        $res{'product_subscription_alerts'}      = getReportRenderedAs($renderMode, 'prodsub', 'alerts');
    }
    
    if($nccreport)
    {
        $res{'subscription_active'}     = getReportRenderedAs($renderMode, 'sub', 'active');
        $res{'subscription_expiresoon'} = getReportRenderedAs($renderMode, 'sub', 'soon');
        $res{'subscription_expired'}    = getReportRenderedAs($renderMode, 'sub', 'expired');
        $res{'subscription_summary'}    = getReportRenderedAs($renderMode, 'sub', 'summary');
        $res{'subscription_alerts'}      = getReportRenderedAs($renderMode, 'sub', 'alerts');
    }
    
    return %res;
}



### MAIN #####################################################################

&Getopt::Long::Configure( 'pass_through', 'no_autoabbrev');
&Getopt::Long::GetOptions(
                          'local'      => \$localreport,
                          'ncc'        => \$nccreport,
                          'nonccsync'  => \$nonccsync,
                          'classreport'=> \$classreport,
                          'debug|d'    => \$debug,
                          'help|h'     => \$help,
                          'mail|m'     => \$mail,
                          'attach|a'   => \$attach,
                          'quiet|q'    => \$quiet,
                          'csv|c'      => \$csv,
                          'file|F:s'   => \$file,      # file name is optional; if missing, it will use a default name 
                          'logfile|L=s'=> \$logfile
                         );

if ( defined $help && ( $help == 1 ) )
{
    printUsage();  
    exit 0;
}

# open the logfile
$LOG = SMT::Utils::openLog($logfile);


# sync current data from NCC
if(!$nonccsync)
{
    my $maxwait = 0;
    while(!SMT::Utils::openLock("smt-ncc-sync") && $maxwait <= 60 )
    {
        # wait for the lock
        $maxwait++;
        sleep 5;
    }

    if($maxwait > 60)
    {
        printLog($LOG, "error", __("Cannot create lockfile. Skip syncing current data from NCC"));
    }
    elsif($maxwait == 0)
    {
        # start sync
        my $lr= SMT::NCCRegTools->new(debug   => $debug,
                                      log     => $LOG);
        
        printLog($LOG, "info", __("Syncing Subscriptions"));
        $lr->NCCListSubscriptions();
        
        printLog($LOG, "info", __("Syncing Registrations"));
        $lr->NCCListRegistrations();
    }
    # else $maxwait > 0 and <=60 means ncc-sync was running. we do not need to sync again.

    SMT::Utils::unLock("smt-ncc-sync");
}


if(!($localreport || $nccreport || $classreport))
{
    # calculate best report

    my $cfg = SMT::Utils::getSMTConfig();
    
    my $fwdr = $cfg->val("LOCAL", "forwardRegistration");
    if(lc($fwdr) eq "true")
    {
        $nccreport = 1;
    }
    else
    {
        $localreport = 1;
    }
}

if($classreport)
{
    $DATA {'class'}   = SMT::CLI::productClassReport(conf => \%conf, log => $LOG, debug => $debug) if($classreport);
}

if($localreport)
{
    $DATA {'prodsub'} = SMT::CLI::productSubscriptionReport(log => $LOG, debug => $debug);
}

if( $nccreport )
{
    $DATA {'sub'}     = SMT::CLI::subscriptionReport(log => $LOG, debug => $debug);
}


# default settings
my $doPrint = 1;
my $doLog = 1; 
my $certErrors = '';
my $datestring = POSIX::strftime("%Y-%m-%d_%H-%M-%S", localtime);
my $defaultFilePrefix = "SMT_report-$datestring";


# set doPrint to 0 if quiet mode selected
if (defined $quiet && $quiet == 1)
{
    $doPrint = 0;
}

# print and log the ascii report if wanted
printLog($LOG, "info", getMergedReport('asciitable'), $doPrint, $doLog);

# print, log and get the certificate check results
$certErrors = certificateCheck($doPrint, $doLog);


if (defined $file)
{
    # exporting the report
    my $fname = '';
    my ($Efile, $Edir, $Eext) = fileparse($file, qr/\.[^.]*/);

    if ($Efile eq '')
    {
        $Efile = $defaultFilePrefix; 
        $Eext  = '';  # trigger automatic extension
    }

    # if file extension is csv we switch to csv export
    if ( (defined $csv && $csv == 1) ||  $Eext eq '.csv' )
    {
        $csv = 1;
    }

    if ($csv)
    {
        if ($Eext eq '') { $Eext = '.csv'; }

        my %rep = getSeparateReports('csv');

        while ( my ($rname, $rdata) = each(%rep) )
        {
            my $extension = $Eext;
            if ($extension eq '.csv'  &&  $rname =~ /alerts/i ) { $extension = '.txt';  }
            $fname = $Edir.$Efile.'-'.$rname.$extension;
            open(REPFILE, "> $fname ")  ||  die sprintf(__("Can not open target file %s"), $fname);
            print REPFILE $rdata;
            close REPFILE;
        }
    }
    else
    {
        $fname = $fname = $Edir.$Efile.$Eext;
        open(REPFILE, "> $fname")  ||  die sprintf(__("Can not open target file %s"), $fname);
        print REPFILE getMergedReport('asciitable');
        close REPFILE;
    }

    if ($certErrors ne '')
    {
        $fname = $Edir.$Efile.'-certificatecheck.txt';
        open(ERRFILE, "> $fname");
        print ERRFILE $certErrors;
        close ERRFILE;
    }
}



if (defined $mail  &&  $mail == 1)
{
    my %ATTACH = ();

    if (defined $attach  &&  $attach == 1)
    {
        my %rep = getSeparateReports('csv');

        while ( my ($rname, $rdata) = each(%rep) )
        {
            my $extension = '.csv';
            if ( $rname =~ /alerts/i ) { $extension = '.txt';  }
            my $csvName = $defaultFilePrefix.'-'.$rname.$extension;
            $ATTACH{$csvName} = $rdata;
        }

        if (defined $certErrors  &&  $certErrors ne '')
        {
            $ATTACH{"$defaultFilePrefix-certificatecheck .txt"} = $certErrors; 
        }
    }

    my $MailBody = '';
    if ($certErrors ne '') { $MailBody .= $certErrors."\n\n"; }
    $MailBody .= getMergedReport('asciitable');

    SMT::Utils::sendMailToAdmins($MailBody, \%ATTACH);
}

exit 0;

#
# Manpage
#

=head1 NAME

smt report -  

=head1 SYNOPSIS

smt [help|--help|-h] report [options]

=head1 DESCRIPTION

smt report


=head1 OPTIONS

=head2 


=head1 AUTHORS and CONTRIBUTORS

Duncan Mac-Vicar Prett, Lukas Ocilka, Jens Daniel Schmidt, Michael Calmer

=head1 LICENSE

Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
