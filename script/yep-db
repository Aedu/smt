#!/usr/bin/perl

use strict;
use warnings;

use lib ("/srv/www/perl-lib/");
use YEP::Utils;
use Getopt::Long qw(:config pass_through no_auto_abbrev);
use Data::Dumper;


my $dbh = undef;
my $sth = undef;

if ( not $dbh=YEP::Utils::db_connect() )
{
    print "ERROR: Could not connect to the database\n";
    return 1;
}


#FIXME get this information dynamically from the database
## database structure
my %TABLES = ( 'catalogs'            =>  { 'catalogid'   => 0,
                                           'name'        => 1,
                                           'description' => 0,
                                           'target'      => 0,
                                           'localpath'   => 1,
                                           'exturl'      => 1,
                                           'catalogtype' => 1,
                                           'domirror'    => 0,
                                           'mirrorable'  => 0
                                         },
               'products'            =>  { 'productdataid' => 1,
                                           'product'       => 1,
                                           'version'       => 1,
                                           'release'       => 1,
                                           'arch'          => 1,
                                           'friendly'      => 1,
                                           'paramlist'     => 0,
                                           'needinfo'      => 0,
                                           'service'       => 0,
                                           'product_list'  => 0
                                         },
               'productcatalogs'     =>  { 'productdataid' => 11,
                                           'catalogid' => 11,
                                           'productdataid-QUERY' => 'products:productdataid:product',
                                           'catalogid-QUERY' => 'catalogs:catalogid:name'
                                         },
               'productdependencies' =>  { 'parent_product_id' => 11,
                                           'child_product_id'  => 11,
                                           'parent_product_id-QUERY' => 'products:productdataid:product',
                                           'child_product_id-QUERY'  => 'products:productdataid:product'
                                         },
               'registration'        =>  { 'guid'      => 1,
                                           'productid' => 11,
                                           'productid-QUERY' => 'products:productdataid:product'
                                         },
               'machinedata'         =>  { 'guid'  => 11,
                                           'guid-QUERY' => 'registration:guid',
                                           'key'   => 1,
                                           'value' => 1
                                         },
               'targets'             =>  { 'os'     => 1,
                                           'target' => 1,
                                           'arch'   => 1
                                         }
             );
## Explanation:
#  QUERY fields decribe the foreign key they represent
#  It consists of a description of the referenced object
#
#  Syntax:  <foreign_table>:<foreign_key>:<foreign_name>
#
# So if a foreign_key is no found in foreign_table and a foreign_name exists,
#   it will search for a foreign_name entry and use its ID.
#
# The values of the parameters:
# 0  = not required
# 1  = required
# 11 = foreign key (a QUERY entry must exist)
#


## database alias names
my %TABS = (
              'catalogs' => 'catalogs',
              'catalog'  => 'catalogs',
              'c'        => 'catalogs',
              'products' => 'products',
              'product'  => 'products',
              'p'        => 'products',
              'productcatalogs'   => 'productcatalogs',
              'productcatalog'    => 'productcatalogs',
              'pc'                => 'productcatalogs',
              'productdependencies' => 'productdependencies',
              'productdependency'   => 'productdependencies',
              'pd'                  => 'productdependencies',
              'registration'  => 'registration',
              'r'             => 'registration',
              'machinedata'   => 'machinedata',
              'm'             => 'machinedata',
              'targets' => 'targets',
              'target' => 'targets',
              't'      => 'targets'
           );


sub checkReference($$$)
{
    my $t = shift;
    my $key = shift;
    my $props = shift;

    my @ref = split( /:/, $TABLES{$t}{$key."-QUERY"} );
    if (scalar(@ref) < 2 || scalar(@ref) > 3) { return 1; }

    my @result = $dbh->selectrow_array(sprintf("select %s from %s where %s = %s ", $ref[1], $ref[0], $ref[1], $dbh->quote(${$props}{$key})) );

    if (scalar(@result) == 0 && scalar(@ref) == 3)
    {   # referenced by name
        @result = $dbh->selectrow_array( sprintf("select %s from %s where %s = %s ", $ref[1], $ref[0], $ref[2], $dbh->quote(${$props}{$key})) );

        if (scalar(@result) == 1)  { ${$props}{$key} = $result[0]; }
    }

    if (scalar(@result) != 1 ) { return 1; }
    return 0;
}


sub insertIntoDB($$)
{
    my $t = shift;
    my $props = shift;

    my $cols = "";
    my $vals = "";

    foreach my $key (keys %{$props})
    {
        $cols = join(',', $cols, $dbh->quote( $key            ) );
        $vals = join(',', $vals, $dbh->quote( ${$props}{$key} ) );
    }

    $cols =~ s/^,//;
    $vals =~ s/^,//;
    $cols =~ s/,$//;
    $vals =~ s/,$//;

    my $ret = $dbh->do( sprintf("insert into %s (%s) values (%s)", $t, $cols, $vals));
}


sub createItem($)
{
    my $target = shift;
    return unless (defined $target && $target ne '');
    my $t = $TABS{$target};
    return unless (defined $t && $t ne '');
    my $th = $TABLES{$t};

    my %props = ();

    foreach my $key (keys %{$th})
    {
        if ($key =~ /-QUERY$/) { next; }
        my $stat = ${$th}{$key};
        my $sep = $stat == 0 ? ":":"=";
        GetOptions(\%props, "$key".$sep."s" );

        if ($stat == 11)
        {
            my $orig = $props{$key};
            my $ret = checkReference($t, $key, \%props);
            if ($ret != 0)
            {
                print "ERROR: Reference $orig does not exist in target table\n";
                exit 11; 
            }
        }
    }

    insertIntoDB($t, \%props);
}


sub usage()
{

print "Usage:   $0 --<action> <target> [--<parameter>  <value>]...

  action
     create|c  -  create new entry
     delete|d  -  delete entry (not yet supported)
     list|l    -  list entries (not yet supported)

  target       -  target table in the database
                  takes table names in plural, singular and abbreviations
                  eg.  
                     products            == product           == p
                     catalogs            == catalog           == c
                     productdependencies == productdependency == pd

  parameter    -  name of a column in target table

  value        -  the value for parameter 
                  (must not start with a dash, otherwise encapsulate with double-quotes)

Examples:

$0 --create product --product myNewServer --version 55
$0 --create catalog --name myNewCatalog --localpath somewhere --exturl elsewhere  --catalogtype other
$0 --create productcatalog --productid myNewServer --catalogid myNewCatalog
$0 --create regisrtation --guid newid --productid myNewServer
$0 --create productdependency --parent_product_id newprod --child_product_id myNewServer

is equivalent to

$0 -c p  --product myNewServer --version 55
$0 -c c  --name myNewCatalog --localpath somewhere --exturl elsewhere  --catalogtype other
$0 -c pc --productid myNewServer --catalogid myNewCatalog
$0 -c r --guid newid --productid myNewServer
$0 -c pd --parent_product_id newprod --child_product_id myNewServer

And the last line is equivalent to (provided the IDs are correct)

$0 -c pd --parent_product_id 123 --child_product_id 456

So it is possible to pass the name of the foreign object as parameter for foreign key ID fields as well as the ID itself.
";


}




my $action = 'help';
my $target = '';
GetOptions("help|h" => \$action);
if ($action ne "help")
{
    usage();
    exit 0;
}

$action = 'create';
GetOptions("create|c:s" => \$target);
if ($target eq '')
{
    $action = 'delete';
    GetOptions("delete|d:s" => \$target);
}

if ($target eq '')
{
    print "ERROR: No action defined\n";
    exit 1;
    #FIXME: print usage
}
elsif ( not defined $TABS{$target} )
{
    print "ERROR: Do not know about ".$target;
    exit 2;
}


### main routine
if ($action eq 'create')
{
    createItem($target);
}
elsif ($action eq 'delete')
{
    print "Delete not implemented yet\n";
    exit 1;
}

