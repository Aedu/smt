#!/usr/bin/env perl

###########################################################################
## Copyright (c) 2007 SUSE LINUX Products GmbH, Nuernberg, Germany.
###########################################################################

use YEP::Mirror::NU;
use YEP::Mirror::RpmMd;
use YEP::Utils;
use YEP::Parser::RegData;
use Config::IniFiles;
use File::Path;
use URI;
use Getopt::Long;
use File::Basename;

use Locale::gettext ();
use POSIX ();     # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

#use Data::Dumper;

my $debug    = 0;
my $clean    = 0;
my $deepverify = 0;

my $dbreplfile = undef;
my $dbreplacement = {};

my $LocalBasePath = "";

my $help     = 0;
my $logfile = "/dev/null";

my $result = GetOptions ("debug|d"     => \$debug,
                         "cleanup|c"   => \$clean,
                         "directory=s" => \$LocalBasePath,
                         "deepverify"  => \$deepverify,
                         "dbreplfile=s" => \$dbreplfile,
                         "logfile|L=s" => \$logfile,
                         "help|h"      => \$help
                        );


if($help)
{
    print basename($0) . __(" [OPTIONS]\n");
    print "\n";
    print __("Options:\n");
    print "--debug -d        " . __("enable debug mode\n");
    print "--clean -c        " . __("cleanup all mirrored repositories.\n");
    print "                  " . __("Remove all files not longer mention in the metadata.\n");
    print "                  " . __("This mode do no mirror before cleanup.\n");
    print "--directory arg   " . __("The directory to work on. Using this option ignores the configured\n");
    print "                  " . __("default value in yep.conf\n");
    print "--deepverify      " . __("Verify all checksums \n");
    print "--dbreplfile arg  " . __("Path to XML file to use as database replacement. Such a file can be created with\n");
    print "                  " . __("the sync-ncc command. This option is only usefull if the yep database is not on the \n");
    print "                  " . __("same host as this script should run\n"); 
    print "--logfile -L file " . __("Path to logfile\n");
    print "--help -h         " . __("show this message\n");
    exit 0;
}


# get a lock

if(!YEP::Utils::openLock("yep-mirror"))
{
    print __("Mirror process is still running.\n");
    exit 0;
}

# open the logfile

my $LOG = YEP::Utils::openLog($logfile);


my $dbh = undef;

if(!defined $dbreplfile)
{
    $dbh = YEP::Utils::db_connect();
    
    if(!$dbh)
    {
        if(!YEP::Utils::unLock("yep-mirror"))
        {
            YEP::Utils::printLog($LOG, "error",  __("Cannot remove lockfile."));
        }
        YEP::Utils::printLog($LOG, "error",  __("Cannot connect to database"));
        exit 1;
    }
}
else
{
    # add a parser
    $dbreplacement = {};
    
    my $parser = YEP::Parser::RegData->new();
    $parser->parse( $dbreplfile, sub { catalog_handler($dbreplacement, @_); });
}


#print Data::Dumper->Dump([$dbreplacement]);

my $cfg = new Config::IniFiles( -file => "/etc/yep.conf" );
if(!defined $cfg)
{
    if(!YEP::Utils::unLock("yep-mirror"))
    {
        YEP::Utils::printLog($LOG, "error",  __("Cannot remove lockfile."));
    }
    YEP::Utils::printLog($LOG, "error", sprintf(__("Cannot read the YEP configuration file: %s"), @Config::IniFiles::errors));
    exit 1;
}

my $NUUrl = $cfg->val("NU", "NUUrl");
if(!defined $NUUrl || $NUUrl eq "")
{
    if(!YEP::Utils::unLock("yep-mirror"))
    {
        YEP::Utils::printLog($LOG, "error", __("Cannot remove lockfile."));
    }
    YEP::Utils::printLog($LOG, "error", __("Cannot read NU Url"));
}

if(!defined $LocalBasePath || $LocalBasePath eq "" || !-d $LocalBasePath)
{
    $LocalBasePath = $cfg->val("LOCAL", "MirrorTo");
    if(!defined $LocalBasePath || $LocalBasePath eq "" || !-d $LocalBasePath)
    {
        if(!YEP::Utils::unLock("yep-mirror"))
        {
            YEP::Utils::printLog($LOG, "error", __("Cannot remove lockfile."));
        }
        YEP::Utils::printLog($LOG, "error", __("Cannot read the local base path"));
        exit 1;
    }
}

my $nuUser = $cfg->val("NU", "NUUser");
my $nuPass = $cfg->val("NU", "NUPass");

if(!defined $nuUser || $nuUser eq "" ||
   !defined $nuPass || $nuPass eq "")
{
    if(!YEP::Utils::unLock("yep-mirror"))
    {
        YEP::Utils::printLog($LOG, "error", __("Cannot remove lockfile."));
    }
    YEP::Utils::printLog($LOG, "error", __("Cannot read the Mirror Credentials"));
    exit 1;
}

my $uri = URI->new($NUUrl);
$uri->userinfo("$nuUser:$nuPass");


my $hash = {};

if(!defined $dbreplfile)
{
    #
    # search for all zypp repositories we need to mirror and start the mirror process
    #
    $hash = $dbh->selectall_hashref( "select CATALOGID, LOCALPATH, EXTURL, CATALOGTYPE from Catalogs where CATALOGTYPE='zypp' and MIRRORABLE='Y' and DOMIRROR='Y'", "CATALOGID" );
}
else
{
    $hash = $dbreplacement;
}

foreach my $id (keys %{$hash})
{
    next if(!exists $hash->{$id}->{CATALOGTYPE} || ! defined $hash->{$id}->{CATALOGTYPE} ||
            lc($hash->{$id}->{CATALOGTYPE}) ne "zypp");
    
    if( $hash->{$id}->{EXTURL} ne "" && $hash->{$id}->{LOCALPATH} ne "" )
    {
        my $fullpath = $LocalBasePath."/repo/".$hash->{$id}->{LOCALPATH};
        &File::Path::mkpath( $fullpath );

        my $zyppMirror = YEP::Mirror::RpmMd->new(debug => $debug, log => $LOG);
        if($clean)
        {
            $zyppMirror->clean( $fullpath );
        }
        else
        {
            $zyppMirror->uri( $hash->{$id}->{EXTURL} );
            $zyppMirror->deepverify($deepverify);
            $zyppMirror->mirrorTo( $fullpath, { urltree => 0 } );
        }
    }
}

#
# Now mirror the NU catalogs
#
my $mirror = YEP::Mirror::NU->new(debug => $debug, log => $LOG);
$mirror->deepverify($deepverify);
if($clean)
{
    $mirror->clean( $LocalBasePath );
}
else
{
    if(defined $dbreplfile)
    {
        $mirror->dbreplacement($dbreplacement);
    }
    
    $mirror->uri( $uri->as_string );
    $mirror->mirrorTo( $LocalBasePath, { urltree => 0 } );
}

# search for Catalogs which has the DOMIRROR flag equals Y but the MIRRORABLE flag to N
if(!defined $dbreplfile)
{
    $hash = $dbh->selectall_hashref( "select CATALOGID, NAME, TARGET, CATALOGTYPE from Catalogs where MIRRORABLE='N' and DOMIRROR='Y'", "CATALOGID" );
    
    if(keys %{$hash} == 0)
    {
        if(!YEP::Utils::unLock("yep-mirror"))
        {
            YEP::Utils::printLog($LOG, "error", __("Cannot remove lockfile."));
            exit 1;
        }
        exit 0;
    }
    
    my $warning = __("WARNING: The following Catalogs cannot be mirrored.\n");
    $warning   .= __("         Maybe you have not enough permissions to download these Catalogs?\n\n");
    
    foreach my $id (keys %{$hash})
    {
        $warning .= "* ".$hash->{$id}->{NAME}." ".$hash->{$id}->{TARGET}."\n";
    }

    YEP::Utils::printLog($LOG, "info", $warning);
}

if(!YEP::Utils::unLock("yep-mirror"))
{
    YEP::Utils::printLog($LOG, "error", __("Cannot remove lockfile."));
    exit 1;
}

exit 0;

sub catalog_handler
{
    my $data = shift;
    my $node = shift;

    #print "called ".Data::Dumper->Dump([$node])."\n";

    if(defined $node && ref($node) eq "HASH" && 
       exists $node->{MAINELEMENT} && defined $node->{MAINELEMENT} &&
       lc($node->{MAINELEMENT}) eq "catalogs")
    {
        my $catname = $node->{NAME};
        if(exists $node->{TARGET} && defined $node->{TARGET} && $node->{TARGET} ne "")
        {
            $catname .= "-".$node->{TARGET};
        }
        #print "Build Catalogname $catname\n";        
        $data->{$catname} = $node;
    }        
}
