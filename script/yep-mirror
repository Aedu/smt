#!/usr/bin/env perl

###########################################################################
## Copyright (c) 2007 SUSE LINUX Products GmbH, Nuernberg, Germany.
###########################################################################

use YEP::Mirror::NU;
use YEP::Mirror::RpmMd;
use YEP::Utils;
use YEP::Parser::RegData;
use Config::IniFiles;
use File::Path;
use URI;
use Getopt::Long;
use File::Basename;

#use Data::Dumper;

my $debug    = 0;
my $clean    = 0;
my $deepverify = 0;

my $dbreplfile = undef;
my $dbreplacement = {};

my $LocalBasePath = "";

my $help     = 0;

my $result = GetOptions ("debug|d"     => \$debug,
                         "cleanup|c"   => \$clean,
                         "directory=s" => \$LocalBasePath,
                         "deepverify"  => \$deepverify,
                         "dbreplfile=s" => \$dbreplfile,
                         "help|h"      => \$help
                        );


if($help)
{
    print basename($0) . " [OPTIONS]\n";
    print "\n";
    print "Options:\n";
    print "--debug -d       enable debug mode\n";
    print "--clean -c       cleanup all mirrored repositories.\n";
    print "                 Remove all files not longer mention in the metadata.\n";
    print "                 This mode do no mirror before cleanup.\n";
    print "--directory arg  The directory to work on. Using this option ignores the configured\n";
    print "                 default value in yep.conf\n";
    print "--deepverify     Verify all checksums \n";
    print "--dbreplfile arg Path to XML file to use as database replacement. Such a file can be created with\n";
    print "                 the sync-ncc command. This option is only usefull if the yep database is not on the \n";
    print "                 same host as this script should run\n"; 
    print "--help -h        show this message\n";
    exit 0;
}

my $dbh = undef;

if(!defined $dbreplfile)
{
    $dbh = YEP::Utils::db_connect();
    
    if(!$dbh)
    {
        die "Cannot connect to database";
    }
}
else
{
    # add a parser
    $dbreplacement = {};
    
    my $parser = YEP::Parser::RegData->new();
    $parser->parse( $dbreplfile, sub { catalog_handler($dbreplacement, @_); });
}


#print Data::Dumper->Dump([$dbreplacement]);

my $cfg = new Config::IniFiles( -file => "/etc/yep.conf" );
if(!defined $cfg)
{
    die "Cannot read the YEP configuration file: ".@Config::IniFiles::errors;
}

my $NUUrl = $cfg->val("NU", "NUUrl");
if(!defined $NUUrl || $NUUrl eq "")
{
    die "Cannot read NU Url";
}

if(!defined $LocalBasePath || $LocalBasePath eq "" || !-d $LocalBasePath)
{
    $LocalBasePath = $cfg->val("LOCAL", "MirrorTo");
    if(!defined $LocalBasePath || $LocalBasePath eq "" || !-d $LocalBasePath)
    {
        die "Cannot read the local base path";
    }
}

my $nuUser = $cfg->val("NU", "NUUser");
my $nuPass = $cfg->val("NU", "NUPass");

if(!defined $nuUser || $nuUser eq "" ||
   !defined $nuPass || $nuPass eq "")
{
    die "Cannot read the Mirror Credentials";
}

my $uri = URI->new($NUUrl);
$uri->userinfo("$nuUser:$nuPass");


my $hash = {};

if(!defined $dbreplfile)
{
    #
    # search for all YUM repositories we need to mirror and start the mirror process
    #
    $hash = $dbh->selectall_hashref( "select CATALOGID, LOCALPATH, EXTURL, CATALOGTYPE from Catalogs where CATALOGTYPE='yum' and MIRRORABLE='Y' and DOMIRROR='Y'", "CATALOGID" );
}
else
{
    $hash = $dbreplacement;
}

print Data::Dumper->Dump([$hash]);

foreach my $id (keys %{$hash})
{
    next if(!exists $hash->{$id}->{CATALOGTYPE} || ! defined $hash->{$id}->{CATALOGTYPE} ||
            $hash->{$id}->{CATALOGTYPE} ne "yum");
    
    if( $hash->{$id}->{EXTURL} ne "" && $hash->{$id}->{LOCALPATH} ne "" )
    {
        my $fullpath = $LocalBasePath."/repo/".$hash->{$id}->{LOCALPATH};
        &File::Path::mkpath( $fullpath );

        my $yumMirror = YEP::Mirror::RpmMd->new(debug => $debug);
        if($clean)
        {
            $yumMirror->clean( $fullpath );
        }
        else
        {
            $yumMirror->uri( $hash->{$id}->{EXTURL} );
            $yumMirror->deepverify($deepverify);
            $yumMirror->mirrorTo( $fullpath, { urltree => 0 } );
        }
    }
}

#
# Now mirror the NU catalogs
#
my $mirror = YEP::Mirror::NU->new(debug => $debug);
$mirror->deepverify($deepverify);
if($clean)
{
    $mirror->clean( $LocalBasePath );
}
else
{
    if(defined $dbreplfile)
    {
        $mirror->dbreplacement($dbreplacement);
    }
    
    $mirror->uri( $uri->as_string );
    $mirror->mirrorTo( $LocalBasePath, { urltree => 0 } );
}

# search for Catalogs which has the DOMIRROR flag equals Y but the MIRRORABLE flag to N
if(!defined $dbreplfile)
{
    $hash = $dbh->selectall_hashref( "select CATALOGID, NAME, TARGET, CATALOGTYPE from Catalogs where MIRRORABLE='N' and DOMIRROR='Y'", "CATALOGID" );
    
    if(keys %{$hash} == 0)
    {
        exit 0;
    }
    
    my $warning = "WARNING: The following Catalogs cannot be mirrored.\n";
    $warning   .= "         Maybe you have not enough permissions to download these Catalogs?\n\n";
    
    foreach my $id (keys %{$hash})
    {
        $warning .= "* ".$hash->{$id}->{NAME}." ".$hash->{$id}->{TARGET}."\n";
    }

    print $warning;
}

exit 0;

sub catalog_handler
{
    my $data = shift;
    my $node = shift;

    #print "called ".Data::Dumper->Dump([$node])."\n";

    if(defined $node && ref($node) eq "HASH" && 
       exists $node->{MAINELEMENT} && defined $node->{MAINELEMENT} &&
       lc($node->{MAINELEMENT}) eq "catalogs")
    {
        my $catname = $node->{NAME};
        if(exists $node->{TARGET} && defined $node->{TARGET} && $node->{TARGET} ne "")
        {
            $catname .= "-".$node->{TARGET};
        }
	#print "Build Catalogname $catname\n";        
        $data->{$catname} = $node;
    }        
}
