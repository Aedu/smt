#!/usr/bin/perl

###############################################################################
## Copyright (c)  2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;
use Getopt::Long;
use SMT::Utils;
use File::Basename;
use File::Temp;
use SMT::JobQueue;
use Log::Log4perl qw(get_logger :levels);

use Data::Dumper;


if( ! SMT::Utils::dropPrivileges() )
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

my $vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1;
my $logfile = "/var/log/smt/smt-jobqueuecleanup.log";
my $debug   = 0;
my $help    = 0;
my $mail     = 0;
my $quiet    = 0;
my $mailtempfile = undef;


Getopt::Long::Configure( 'no_auto_abbrev');
my $optres = GetOptions ("debug|d"     => \$debug,
                         "verboselevel|v=i" => \$vblevel,
                         "logfile|L=s" => \$logfile,
                         "mail|m"      => \$mail,
                         "help|h"      => \$help,
                         "quiet|q"      => \$quiet
                        );


if($help || !$optres)
{
    print basename($0) . " [--logfile file] [--debug] [--mail]\n\n";
    print __("Clean up the SMT JobQueue and remove invalid or obsoleted jobs.")."\n";
    print "\n";
    print __("Options:")."\n";
    print "--mail -m                 ".__("Send output as e-mail to the administrators defined in reportEmail in smt.conf.")."\n";
    print "                          ".__("The output on stdout and stderr will be suppressed.")."\n";
    print "--quiet -q                ".__("suppress output")."\n";
    print "--debug -d                ".__("enable debug mode")."\n";
    print "--verboselevel -v <level> ".__("set the verbose level")."\n";
    print "--logfile -L <file>       ".__("Path to logfile")."\n";
    exit 0;
}

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);

# open the logfile

Log::Log4perl::init("/etc/smt.d/log4perl.conf");

# to change the loglevel we need the root logger,
# not the derived main logger
my $log = get_logger('');
$log->level(SMT::Utils::vblevel2log4perl4File($vblevel));
my $out = get_logger('userlogger');
$out->level(SMT::Utils::vblevel2log4perl4Screen($vblevel));
my $emailapp = undef;
if($mail)
{
  $emailapp =  Log::Log4perl::Appender->new("Log::Log4perl::Appender::TmpFileBuffer",
                                            name => 'email');
                                            my $layout = Log::Log4perl::Layout::PatternLayout->new("%m%n");
  $emailapp->layout($layout);
  $out->add_appender($emailapp);
}

# read smt config
my $cfg = undef;
eval {  $cfg = SMT::Utils::getSMTConfig();  };
if( $@ || ! defined $cfg )
{
  my $err = $@;
  chomp($err);
  $log->error(sprintf("Cannot read the SMT configuration file: %s", $err));
  $out->error(sprintf(__("Cannot read the SMT configuration file: %s"), $err));
  if ($mail && $emailapp)
  {
    my $datestring = POSIX::strftime("%Y-%m-%d %H:%M", localtime);
    my $subject = sprintf("SMT JobQueue Cleanup $datestring (%s)", SMT::Utils::getFQDN());
    SMT::Utils::sendMailToAdmins($subject, $emailapp->get_buffer());
  }
  exit 1;
}

# connect to database
my $dbh = undef;
$dbh = SMT::Utils::db_connect();
if( ! $dbh )
{
  $log->error("Cannot connect to database");
  $out->error(__("Cannot connect to database"));
  if ($mail && $emailapp)
  {
    my $datestring = POSIX::strftime("%Y-%m-%d %H:%M", localtime);
    my $subject = sprintf("SMT JobQueue Cleanup $datestring (%s)", SMT::Utils::getFQDN());
    SMT::Utils::sendMailToAdmins($subject, $emailapp->get_buffer());
  }
  exit 1;
}
my $res = undef;


###############################################################################
# Cleanup JobQueue

$log->info("Starting daily SMT JobQueue cleanup");
$out->info(__("Starting daily SMT JobQueue cleanup"));
my $maxDays = $cfg->val('JOBQUEUE', 'maxFinishedJobAge') || 8;



### DELETE OLD FINISHED JOBS (first) ###

my $delOldJobsSQL = " DELETE FROM JobQueue where DATE_ADD(FINISHED, INTERVAL $maxDays DAY) < NOW() AND PERSISTENT = 0 ";
$res = $dbh->do($delOldJobsSQL);
$log->info(sprintf("Number of deleted finished jobs: %s", ($res =~ /^0E0$/) ? "0":$res));
$out->info(sprintf(__("Number of deleted finished jobs: %s"), ($res =~ /^0E0$/) ? "0":$res)) if(!quiet);



### DELETE JOB COOKIES (second) ###

my $delOldJobCookiesSQL = " DELETE FROM JobQueue where TYPE = 0 and DATE_ADD(CREATED, INTERVAL 1 DAY) < NOW() ";
$res = $dbh->do($delOldJobCookiesSQL);
$log->info(sprintf("Number of deleted job cookies: %s", ($res =~ /^0E0$/) ? "0":$res));
$out->info(sprintf(__("Number of deleted job cookies: %s"), ($res =~ /^0E0$/) ? "0":$res)) if(!$quiet);


### CHECK FOR UNSUPPORTED JOB TYPES (third) ###

my $delUnsupportedJobsSQL = " DELETE FROM JobQueue where TYPE >= 9 ";
$res = $dbh->do($delUnsupportedJobsSQL);
$log->info(sprintf("Number of deleted unsupported jobs: %s", ($res =~ /^0E0$/) ? "0":$res));
$out->info(sprintf(__("Number of deleted unsupported jobs: %s"), ($res =~ /^0E0$/) ? "0":$res)) if(!$quiet);


### CHECK PARENTS (fourth) ###

# get all dependent jobs older than one day
my $getParentDataSQL = " SELECT ID, GUID_ID, PARENT_ID from JobQueue where PARENT_ID IS NOT NULL AND DATE_ADD(CREATED, INTERVAL 1 DAY) < NOW() ";
my $pData = $dbh->selectall_hashref($getParentDataSQL, ["GUID_ID", "ID"] );

# get reference data from JobQueue to compare the filtered data with (bnc#520701)
my $JobQ = SMT::JobQueue->new({ 'dbh' => $dbh});
my $refData = $JobQ->getJobsInfo({ 'ID' => '', 'GUID' => '', 'PARENT_ID' => '' });

my @delBrokenParentsWhere = ();

foreach my $gid ( keys %{$pData} )
{
     foreach my $jid ( keys %{${$pData}{$gid}} )
     {
         if ( defined ${$pData}{$gid}{$jid}{PARENT_ID} )
         {
             # compare the found parent job with the reference data (bnc#520701)
             if ( not exists ${$refData}{$gid}{ ${$pData}{$gid}{$jid}{PARENT_ID} } )
             {
                 push(@delBrokenParentsWhere, " ( ID = $jid AND GUID_ID = ${$pData}{$gid}{$jid}{GUID_ID} ) ");
             }
         }
    }
}

my $whereStr = '';
$whereStr = join(" OR ", @delBrokenParentsWhere );

if ( defined $whereStr && $whereStr ne '' )
{
    my $delBrokenParentsSQL = " DELETE FROM JobQueue where $whereStr" ;
    $res = $dbh->do($delBrokenParentsSQL);
    $log->info(sprintf("Number of deleted jobs with broken parent IDs: %s", ($res =~ /^0E0$/) ? "0":$res));
    $out->info(sprintf(__("Number of deleted jobs with broken parent IDs: %s"), ($res =~ /^0E0$/) ? "0":$res)) if(!$quiet);
}
else
{
    $log->info("Number of deleted jobs with broken parent IDs is: 0");
    $out->info(__("Number of deleted jobs with broken parent IDs is: 0")) if(!$quiet);
}




### CHECK PERSISTENT JOBS FOR PROPER TIMELAG [> 1 minute] (last) ###

# make all job info hashes look consistent (like JobQueue would return them) to prevent bugs like (bnc#520701)
my $getTooPersistentJobs = " SELECT  j.GUID_ID, c.GUID, j.ID, j.TIMELAG from JobQueue j LEFT JOIN Clients c ON (j.GUID_ID = c.ID) where j.PERSISTENT = 1 AND ( j.TIMELAG < '00:01:00'  OR  j.TIMELAG IS NULL ) ";
my $persData = $dbh->selectall_hashref($getTooPersistentJobs, ["GUID_ID", "ID"] );

my $numPersData = keys %{$persData} || 0;
if ( $numPersData > 0 )
{
    $log->info(sprintf("Number persistent jobs with a timelag smaller than 1 minute: %s", $numPersData ));
    $out->info(sprintf(__("Number persistent jobs with a timelag smaller than 1 minute: %s"),
                       $numPersData )) if(!$quiet);
    
    foreach my $gid ( keys %{$persData} )
    {
        foreach my $jid (keys %{${$persData}{$gid}} )
        {
            $log->info(sprintf("Job ID (%s) for GUID (%s) has a timelag of (%s).", 
                               $jid, ${$persData}{$gid}{$jid}{GUID}, ${$persData}{$gid}{$jid}{TIMELAG} || 0 ));
            $out->info(sprintf("Job ID (%s) for GUID (%s) has a timelag of (%s).", 
                               $jid, ${$persData}{$gid}{$jid}{GUID}, ${$persData}{$gid}{$jid}{TIMELAG} || 0 )) if(!$quiet);
        }
    }
    $log->info("This is just a warning. If the timelag for these jobs is not intended to be so small please change the jobs using the smt-job command.");
    $out->info(__("This is just a warning. If the timelag for these jobs is not intended to be so small please change the jobs using the smt-job command.")) if(!$quiet);
}
else
{
    $log->info("No persistent jobs with a timelag smaller than 1 minute found. Good.");
    $out->info(__("No persistent jobs with a timelag smaller than 1 minute found. Good.")) if(!$quiet);
}


### SEND MAIL ###

if ($mail && $emailapp)
{
  my $datestring = POSIX::strftime("%Y-%m-%d %H:%M", localtime);
  my $subject = sprintf("SMT JobQueue Cleanup $datestring (%s)", SMT::Utils::getFQDN());
  SMT::Utils::sendMailToAdmins($subject, $emailapp->get_buffer());
}

