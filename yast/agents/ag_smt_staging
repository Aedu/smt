#!/usr/bin/perl -w

#
# File:
#   ag_smt_staging
#
# Authors:
#   Lukas Ocilka <locilka@suse.cz>
#
# Description:
#   SCR agent for catalogs staging management
#
# $Id$
#


use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;
use strict;

use SMT::Utils;
use SMT::CLI;
use SMT::Filter;
use SMT::Parser::RpmMdPatches;

# FIXME? Is is needed? For debugging?
use Data::Dumper;

if(! SMT::Utils::dropPrivileges()) {
    y2error ('Unable to drop privileges. Aborting...');
    ycp::Return (undef);
    exit 1;
}

# Initialize SMT
my ($cfg, $dbh, $nuri) = SMT::CLI::init();
my $base_path = $cfg->val("LOCAL", "MirrorTo") || '/srv/www/htdocs';

use constant {
    YCP_TRUE	=> 'true',
    YCP_FALSE	=> 'false',
};

# Reports that the agent has been called using an unsupported path
sub UnsupportedPath ($$) {
    my ($command_ref, $path_ref) = (shift, shift);

    y2error ('Unsupported path: '.$$path_ref.' for command '.$$command_ref);
    ycp::Return (undef);
}

# FIXME: move to a module, share ...
sub GetAllCatalogs () {
    my $sth = $dbh->prepare("SELECT * FROM Catalogs where DOMIRROR='Y' and STAGING='Y'");
    $sth->execute();
    my @ret;
    while (my $row = $sth->fetchrow_hashref()) {
	$row->{TARGET} = "" if (not defined $row->{TARGET});
	push @ret, $row;
    }
    return \@ret;
}

# FIXME: move to a module, share ...
sub GetCatalogPath ($) {
    my $catalogid = shift || '';

    if ($catalogid eq '') {
	y2error ("CatalogID must be defined");
	return undef;
    }

    my $catalogs = GetAllCatalogs();
    my $catalog_local_path = '';

    foreach my $catalog (@{$catalogs}) {
	# Required catalog matches the current one
	if (defined $catalog->{'CATALOGID'} && $catalog->{'CATALOGID'} eq $catalogid) {
	    if (defined $catalog->{'LOCALPATH'}) {
		$catalog_local_path = $catalog->{'LOCALPATH'};
		last;
	    } else {
		y2error ("Catalog ".$catalogid." matches but no 'LOCALPATH' is defined");
	    }
	}
    }

    return $catalog_local_path;
}

# Filters and Patches Handles
my $fph = {};

# Initializes required handles (in not yet initialized)
# loads filters
sub LoadCatalogData ($) {
    my $catalogid = shift || "";

    # No catalog ID defined, unable to load data
    if ($catalogid eq "") {
	y2error ("Catalog ID must be defined");
	return undef;
    }

    # Already loaded
    if (defined $fph->{$catalogid}) {
	return 1;
    }

    my $ret = 1;

    # New empty Handler
    $fph->{$catalogid} = {};

    # New Filter handler
    $fph->{$catalogid}->{'fh'} = SMT::Filter->new();
    if (! $fph->{$catalogid}->{'fh'}->load($dbh, $catalogid)) {
	y2error ("Cannot load filters for catalog: ".$catalogid);
	$ret = 0;
    }

    my $repo_path = $base_path.'/repo/'.GetCatalogPath($catalogid);
    y2internal ("Using local path: ".$repo_path);

    # The following lines should go to a module in SMT package
    # New Patches-Parser handler
    $fph->{$catalogid}->{'ph'} = SMT::Parser::RpmMdPatches->new();
    $fph->{$catalogid}->{'ph'}->resource($repo_path);
    $fph->{$catalogid}->{'ph'}->parse("repodata/updateinfo.xml.gz", "repodata/patches.xml");

    return $ret;
}

# Goes through all the SMT::Filter handles and saves the data
# catalog by catalog
sub WritePatchFilters () {
    my $catalogid = '';

    my $ret = 1;

    foreach $catalogid (keys %{$fph}) {
	y2milestone ("Calling save() on Catalog:".$catalogid);
	if (! $fph->{$catalogid}->{'fh'}->save($dbh, $catalogid)) {
	    y2error ("Error saving catalog ".$catalogid);
	    $ret = 0;
	}
    }

    return ($ret ? YCP_TRUE:YCP_FALSE);
}

# Returns patches with their status
sub GetAllPatches ($) {
    my $catalogid = shift || "";

    if ($catalogid eq "") {
	y2error ("Catalog ID must be defined");
	return undef;
    }

    y2milestone ("Handling CatalogID: ".$catalogid);

    LoadCatalogData($catalogid);

    my @ret;
    my $patchname = "";
    my $tmppatch = {};

    foreach my $patchid (keys %{$fph->{$catalogid}->{'ph'}->{'PATCHES'}}) {
	$tmppatch = $fph->{$catalogid}->{'ph'}->{'PATCHES'}->{$patchid};
	$tmppatch->{'patchid'} = $patchid;
	$tmppatch->{'filtered'} = ($fph->{$catalogid}->{'fh'}->matches($tmppatch) ? YCP_TRUE:YCP_FALSE);
	push @ret, $tmppatch;
    }

    return \@ret;
}

# Changes the patch status by adding or removing TYPE_NAME_VERSION filter
# Patches can be matching another filters though
sub ChangePatchStatus ($) {
    my $params = shift;

    my $catalogid	= $params->{'catalogid'}	|| '';
    my $patchid		= $params->{'patchid'}		|| '';
    my $new_status	= $params->{'status'}		|| '';

    if ($catalogid eq '') {
	y2error ("Parameter 'catalogid' not defined");
	return YCP_FALSE;
    }
    if ($patchid eq '') {
	y2error ("Parameter 'patchid' not defined");
	return YCP_FALSE;
    }

    LoadCatalogData($catalogid);

    # true -> wanted in testig repository
    if ($new_status) {
	$fph->{$catalogid}->{'fh'}->remove(SMT::Filter::TYPE_NAME_VERSION, $patchid);
    # false -> not wanted
    } else {
	$fph->{$catalogid}->{'fh'}->add(SMT::Filter::TYPE_NAME_VERSION, $patchid);
    }

    return YCP_TRUE;
}

sub GetPatchStatus ($) {
    my $params = shift;

    my $catalogid	= $params->{'catalogid'}	|| '';
    my $patchid		= $params->{'patchid'}		|| '';

    if ($catalogid eq '') {
	y2error ("Parameter 'catalogid' not defined");
	return undef;
    }
    if ($patchid eq '') {
	y2error ("Parameter 'patchid' not defined");
	return undef;
    }

    LoadCatalogData($catalogid);

    my $this_patch = $fph->{$catalogid}->{'ph'}->{'PATCHES'}->{$patchid};
    # The current patch status (in testing repo) -> ! matching (filters)
    return ($fph->{$catalogid}->{'fh'}->matches($this_patch) ? YCP_FALSE:YCP_TRUE);
}

# Returns whether a given filter exists
#
# $param->{'catalogid'} - hash to identyfy a catalog
# $param->{'type'} - one of the well known types
# $param->{'filter'} - filter string
sub FilterExists ($) {
    my $params = shift;

    my $catalogid	= $params->{'catalogid'}	|| '';
    my $type		= $params->{'type'}		|| '';
    my $filter		= $params->{'filter'}		|| '';

    if ($catalogid eq '') {
	y2error ("Parameter 'catalogid' not defined");
	return undef;
    }
    if ($type eq '') {
	y2error ("Parameter 'type' not defined");
	return undef;
    }
    if ($filter eq '') {
	y2error ("Parameter 'filter' not defined");
	return undef;
    }

    LoadCatalogData($catalogid);
    return $fph->{$catalogid}->{'fh'}->contains($type, $filter);
}

sub SecurityLevelFilterExists ($) {
    my $arg = shift;

    my $func_args = {
	'type' => SMT::Filter::TYPE_SECURITY_LEVEL,
	# filter string is the security level of a patch
	'filter' => (defined $arg->{'type'} ? $arg->{'type'}:''),
	'catalogid' => (defined $arg->{'catalogid'} ? $arg->{'catalogid'}:''),
    };

    return (FilterExists ($func_args) ? YCP_TRUE:YCP_FALSE);
}

# the main() loop
while (<STDIN>) {
    my ($command, $path, $arg) = ycp::ParseCommand ($_);
    # FIXME: remove this line (just for debugging)
    y2internal ('Command:'.Dumper($command).' Path:'.Dumper($path).' Arg:'.Dumper($arg));

    # For Perl-only testing, otherwise already removed
    if ($path =~ /^\.smt\.staging/) {
	$path =~ s/^\.smt\.staging//;
    }

    if ($command eq 'Read') {
	if ($path eq '.catalogs') {
	    ycp::Return (GetAllCatalogs ());
	} elsif ($path eq '.patches') {
	    ycp::Return (GetAllPatches ($arg));
	} elsif ($path eq '.patch.testing') {
	    ycp::Return (GetPatchStatus ($arg));
	} elsif ($path eq '.category_filter') {
	    ycp::Return (SecurityLevelFilterExists ($arg));
	} else {
	    UnsupportedPath (\$command, \$path);
	}
    } elsif ($command eq 'Write') {
	if ($path eq '.patch.testing') {
	    ycp::Return (ChangePatchStatus ($arg));
	} elsif ($path eq '.patches') {
	    ycp::Return (WritePatchFilters());
	} else {
	    UnsupportedPath (\$command, \$path);
	}
    } elsif ($command eq 'Execute') {
	if ($path eq '.production') {
	    # FIXME
	    ycp::Return (YCP_TRUE);
	} else {
	    UnsupportedPath (\$command, \$path);
	    ycp::Return (undef);
	}
    # destructor
    } elsif ($command eq 'result') {
	y2milestone ('Bye bye...');
    } else {
	y2error ('Unknown SCR command: '.$command);
	ycp::Return (undef);
    }
}
# the main() loop

exit 0;
